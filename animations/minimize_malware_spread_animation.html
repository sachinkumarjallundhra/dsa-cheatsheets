<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimize Malware Spread (Union-Find Animation)</title>
    <style>
        :root {
            --color-bg-light: #f4f7f6; --color-bg-panel: #ffffff; --color-text-dark: #2c3e50;
            --color-primary: #3498db; --color-success: #2ecc71; --color-danger: #e74c3c;
            --color-warning: #f1c40f;
            --color-node-default: #bdc3c7; --color-node-malware: #e74c3c;
            --color-edge-default: #ccc;
            --color-cell-read: #fff3cd; --color-cell-write: #e8f5e9; --color-cell-find: #e9d8fd;
        }
        html, body {
            height: 100%; margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: var(--color-bg-light);
        }
        .dashboard-container {
            display: grid; grid-template-columns: minmax(450px, 1.2fr) 2fr minmax(450px, 1fr);
            grid-template-rows: auto 1fr; grid-template-areas: "header header header" "left main right";
            gap: 15px; padding: 15px; height: 100%; box-sizing: border-box;
        }
        .panel { background-color: var(--color-bg-panel); border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); padding: 15px; display: flex; flex-direction: column; min-height: 0; }
        h1, h2 { color: var(--color-text-dark); text-align: center; margin-top: 0; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid #eee;}
        h1 { font-size: 1.5em; border: none; } h2 { font-size: 1.1em; }

        .header { grid-area: header; }
        .controls { display: flex; flex-wrap: wrap; gap: 15px; padding: 10px; background-color: #e8f0fe; border-radius: 5px; align-items: center; justify-content: center;}
        .controls textarea { padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-family: 'Courier New', monospace; width: 450px; height: 60px; resize: vertical; }
        .controls button { padding: 10px 15px; background-color: var(--color-primary); color: white; border: none; border-radius: 4px; cursor: pointer; }
        .controls button:disabled { background-color: #bdc3c7; }

        .left-column { grid-area: left; display: flex; flex-direction: column; gap: 15px; min-height: 0; }
        .main-column { grid-area: main; display: flex; flex-direction: column; min-height: 0; }
        .right-column { grid-area: right; display: grid; grid-template-rows: auto 1fr; gap: 15px; min-height: 0; }
        
        #code_container { background: #2d2d2d; color: #f1f1f1; font-family: 'Courier New', monospace; font-size: 0.8em; flex-shrink: 1; overflow-y: auto;}
        .code-line { padding: 2px 5px; border-radius: 3px; transition: background-color 0.3s; }
        .code-line.highlight { background-color: #555; }
        #action_display { text-align: center; font-weight: bold; font-size: 1.1em; background: #f8f9fa; }
        
        #graph_container { position: relative; width: 100%; flex-grow: 1; background: #fafafa; border-radius: 5px; border: 1px solid #e0e0e0; overflow: hidden; }
        .graph-node text { font-family: 'Segoe UI', sans-serif; font-size: 12px; font-weight: bold; pointer-events: none; fill: white; }
        .malware-icon { fill: white; }

        .data-container { overflow-y: auto; padding: 5px; background: #fafafa; border-radius: 4px; min-height: 0;}
        .right-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .array-panel { display: flex; flex-direction: column;}
        .array-cell { border: 1px solid #ccc; border-radius: 4px; text-align: center; margin-bottom: 4px; }
        .array-cell .idx { background: #f2f2f2; font-weight: bold; padding: 2px; border-bottom: 1px solid #ccc; font-size: 0.7em; }
        .array-cell .val { padding: 5px 2px; font-family: 'Courier New', monospace; font-size: 0.9em; transition: background-color 0.3s ease; }
        .array-cell .val.read { background-color: var(--color-cell-read); }
        .array-cell .val.write { background-color: var(--color-cell-update); }
        .array-cell.find .idx { background-color: var(--color-cell-find); }
        
        .decision-panel { border: 2px solid var(--color-primary); border-radius: 5px; padding: 10px; font-family: 'Courier New', monospace; font-size: 0.9em; }
        .decision-panel > div { margin-bottom: 5px; }
        .decision-panel span { font-weight: bold; }
        .decision-panel .good { color: var(--color-success); }
        .decision-panel .bad { color: var(--color-danger); }

        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background: white; padding: 30px; border-radius: 8px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        #final_result_text { font-size: 1.8em; font-weight: bold; margin: 0; color: var(--color-primary); }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <header class="header panel">
            <h1>Minimize Malware Spread</h1>
            <div class="controls">
                <label>Graph:</label><textarea id="graph_input">[[1,1,0],[1,1,0],[0,0,1]]</textarea>
                <label>Initial:</label><textarea id="initial_input">[0,1]</textarea>
                <button id="start_button">Start</button>
                <button id="next_step_button" disabled>Next Step</button>
            </div>
        </header>

        <div class="left-column">
            <div class="panel">
                <h2>Algorithm</h2>
                <div id="code_container"></div>
            </div>
            <div class="panel" style="flex-grow: 0; flex-shrink: 0;">
                <h2>Current Action</h2>
                <div id="action_display">Enter parameters and click 'Start'.</div>
            </div>
        </div>

        <div class="main-column panel">
            <h2>Network Graph</h2>
            <div id="graph_container">
                 <svg id="graph_svg" width="100%" height="100%"></svg>
            </div>
        </div>

        <div class="right-column">
             <div class="panel">
                <h2 id="decision_panel_title">Analysis</h2>
                <div id="decision_container" class="data-container"></div>
            </div>
            <div class="panel">
                <h2>Data Arrays</h2>
                <div id="arrays_container" class="data-container right-grid">
                    <div class="array-panel" id="parent_array_container"></div>
                    <div class="array-panel" id="size_array_container"></div>
                    <div class="array-panel" id="malware_array_container"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="result_modal" class="modal-overlay">
        <div class="modal-content">
            <h2>Optimal Node to Remove</h2>
            <p id="final_result_text"></p>
            <button id="modal_close_btn" class="controls button">Close</button>
        </div>
    </div>

<script>
let animationSteps = [], currentStepIndex = 0, simulationRunning = false;
let graphInput, initialInput, startButton, nextStepButton, codeContainer, actionDisplay, graphContainer,
    decisionContainer, parentArrayContainer, sizeArrayContainer, malwareArrayContainer, decisionPanelTitle,
    resultModal, finalResultText, modalCloseBtn;
let graphDrawer, componentColors = [];

class GraphDrawer {
    constructor(svg, n, initial) {
        this.svg = svg;
        this.n = n;
        this.nodes = [];
        this.initial = initial;

        const width = svg.parentElement.clientWidth;
        const height = svg.parentElement.clientHeight;
        const cx = width / 2;
        const cy = height / 2;
        const radius = Math.min(width, height) / 2 - 40;

        for (let i = 0; i < n; i++) {
            const angle = (i / n) * 2 * Math.PI - Math.PI / 2;
            this.nodes[i] = {
                id: i,
                x: cx + radius * Math.cos(angle),
                y: cy + radius * Math.sin(angle)
            };
        }
    }

    draw(state, findRootHelper) {
        this.svg.innerHTML = ''; // Simple clear
        const { graph, parent, highlights } = state;
        
        const roots = new Set();
        for(let i=0; i<this.n; i++) roots.add(findRootHelper(parent, i));
        const rootColorMap = new Map();
        [...roots].forEach((root, i) => {
            rootColorMap.set(root, componentColors[i % componentColors.length]);
        });

        // Draw edges
        for (let i = 0; i < this.n; i++) {
            for (let j = i + 1; j < this.n; j++) {
                if (graph[i][j] === 1) {
                    const source = this.nodes[i];
                    const target = this.nodes[j];
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', source.x); line.setAttribute('y1', source.y);
                    line.setAttribute('x2', target.x); line.setAttribute('y2', target.y);
                    line.setAttribute('stroke', 'var(--color-edge-default)');
                    line.setAttribute('stroke-width', 2);
                    this.svg.appendChild(line);
                }
            }
        }
        
        // Draw nodes
        this.nodes.forEach(node => {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.classList.add('graph-node');
            g.setAttribute('transform', `translate(${node.x},${node.y})`);
            
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('r', 18);
            const root = findRootHelper(parent, node.id);
            const color = rootColorMap.get(root) || 'var(--color-node-default)';
            circle.setAttribute('fill', color);
            let stroke = '#333';
            if(highlights.node === node.id) stroke = 'var(--color-warning)';
            if(highlights.finalResultNode === node.id) stroke = 'var(--color-success)';
            circle.setAttribute('stroke', stroke);
            circle.setAttribute('stroke-width', 3);
            g.appendChild(circle);

            if (this.initial.includes(node.id)) {
                 const icon = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                 icon.setAttribute('d', 'M10.5,6.5A3.5,3.5 0 0,0 7,10A3.5,3.5 0 0,0 10.5,13.5A3.5,3.5 0 0,0 14,10A3.5,3.5 0 0,0 10.5,6.5M10.5,8A2,2 0 0,1 12.5,10A2,2 0 0,1 10.5,12A2,2 0 0,1 8.5,10A2,2 0 0,1 10.5,8M16.5,4H14.88L15.3,3.34L14.24,2.28L13.26,3.63C12.4,3.23 11.47,3 10.5,3C9.53,3 8.6,3.23 7.74,3.63L6.76,2.28L5.7,3.34L6.12,4H4.5A2,2 0 0,0 2.5,6V7.5L3.87,6.73L5.13,7.9L3.5,9.5H2V11.5H3.5L5.13,13.09L3.87,14.26L2.5,13.5V15A2,2 0 0,0 4.5,17H6.12L5.7,17.66L6.76,18.72L7.74,17.37C8.6,17.77 9.53,18 10.5,18C11.47,18 12.4,17.77 13.26,17.37L14.24,18.72L15.3,17.66L14.88,17H16.5A2,2 0 0,0 18.5,15V13.5L17.13,14.27L15.87,13.1L17.5,11.5H19V9.5H17.5L15.87,7.9L17.13,6.73L18.5,7.5V6A2,2 0 0,0 16.5,4Z');
                 icon.classList.add('malware-icon');
                 icon.setAttribute('transform', 'translate(-10.5, -10.5) scale(0.9)');
                 g.appendChild(icon);
            } else {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dy', '0.35em');
                text.textContent = node.id;
                g.appendChild(text);
            }
            this.svg.appendChild(g);
        });
    }
}


class MalwareAnimation {
    constructor() { this.reset(); }
    reset() {
        animationSteps = []; currentStepIndex = 0; simulationRunning = false;
        componentColors = [];
        this.updateButtons(); this.clearDisplays();
        resultModal.style.display = 'none';
    }
    clearDisplays() {
        if (!codeContainer) return;
        [codeContainer, decisionContainer, parentArrayContainer, sizeArrayContainer, malwareArrayContainer].forEach(c => c.innerHTML = '');
        const svg = document.getElementById('graph_svg');
        if(svg) svg.innerHTML = '';
        decisionPanelTitle.textContent = "Analysis";
        actionDisplay.textContent = 'Enter parameters and click \'Start\'.';
    }
    start() {
        this.reset();
        try {
            const graph = JSON.parse(graphInput.value.trim());
            const initial = JSON.parse(initialInput.value.trim());
            if (!Array.isArray(graph) || !Array.isArray(initial)) throw new Error("Invalid input.");
            
            this.initUI();
            const n = graph.length;
            for(let i=0; i<n; i++) componentColors.push(`hsl(${i * (360 / (n+1))}, 60%, 70%)`);

            graphDrawer = new GraphDrawer(document.getElementById('graph_svg'), n, initial);
            animationSteps = this.generateSteps(graph, initial);
            
            simulationRunning = true;
            if (animationSteps.length > 0) this.renderState(animationSteps[0]);
            this.updateButtons();
        } catch(e) {
            console.error(e);
            alert("Invalid input. Error: " + e.message);
            this.reset();
        }
    }
    next() {
        if (!simulationRunning || currentStepIndex >= animationSteps.length - 1) return;
        currentStepIndex++;
        this.renderState(animationSteps[currentStepIndex]);
        this.updateButtons();
    }
    updateButtons() {
        startButton.textContent = simulationRunning ? "Reset" : "Start";
        nextStepButton.disabled = !simulationRunning || currentStepIndex >= animationSteps.length - 1;
    }
    
    initUI() {
        const code = [
            "// Phase 1: Build Components",
            "for i=0..n, for j=i+1..n:",
            "  if graph[i][j]==1: uf.union(i, j)",
            "",
            "// Phase 2: Calculate Component Sizes",
            "for i=0..n: size[uf.find(i)]++",
            "",
            "// Phase 3: Count Malware per Component",
            "for node in initial: malware[uf.find(node)]++",
            "",
            "// Phase 4: Find Best Node to Remove",
            "for node in sorted(initial):",
            "  root = uf.find(node)",
            "  if malware[root]==1 and size[root]>maxSaved:",
            "    maxSaved=size[root]; res=node;",
            "return res != -1 ? res : sorted_initial[0]",
        ];
        codeContainer.innerHTML = code.map((line, i) => `<div class="code-line" id="code-line-${i}">${line.replace(/ /g, '&nbsp;')}</div>`).join('');
    }

    generateSteps(graph, initial) {
        const steps = [];
        const save = (data) => steps.push(JSON.parse(JSON.stringify(data)));
        const n = graph.length;
        
        // UF logic is now managed locally in generateSteps, not stored in state
        const uf = {
            parent: Array.from({length: n}, (_, i)=>i),
            find: function(x) {
                if (this.parent[x] === x) return x;
                return this.parent[x] = this.find(this.parent[x]);
            },
            union: function(x,y) {
                const rootX = this.find(x), rootY = this.find(y);
                if (rootX !== rootY) this.parent[rootX] = rootY;
            }
        };
        
        let state = {
            phase: 'union', graph, initial, parent: [...uf.parent], size: [], malware: [],
            decision: { candidate: null, malwareCount: null, size: null, maxSaved: -1, res: -1 },
            highlights: { node: null, cell: null, finalResultNode: null },
            finalResult: null
        };
        
        save({ ...state, line: 0, msg: "Phase 1: Build components by unioning connected nodes." });
        for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
                if (graph[i][j] === 1) {
                    state.highlights.node = [i, j];
                    save({ ...state, msg: `Found connection between ${i} and ${j}.` });
                    uf.union(i, j);
                    state.parent = [...uf.parent];
                    save({ ...state, line: 2, msg: `Union(${i}, ${j}). Parent array updated.` });
                }
            }
        }

        state.phase = 'sizing'; state.highlights = {};
        state.size = Array(n).fill(0);
        save({ ...state, line: 4, msg: "Phase 2: Calculate size of each component." });
        for (let i = 0; i < n; i++) {
            const root = uf.find(i);
            state.highlights = { node: i, cell: { array: 'size', index: root, op: 'write' } };
            save({ ...state, msg: `Node ${i} belongs to component with root ${root}.` });
            state.size[root]++;
            save({ ...state, msg: `Incrementing size of component ${root} to ${state.size[root]}.` });
        }
        
        state.phase = 'malware_count'; state.highlights = {};
        state.malware = Array(n).fill(0);
        save({ ...state, line: 7, msg: "Phase 3: Count initial malware in each component." });
        for (const node of initial) {
            const root = uf.find(node);
            state.highlights = { node: node, cell: { array: 'malware', index: root, op: 'write' } };
            save({ ...state, msg: `Malware node ${node} belongs to component ${root}.` });
            state.malware[root]++;
            save({ ...state, msg: `Incrementing malware count for component ${root} to ${state.malware[root]}.` });
        }
        
        state.phase = 'decision'; state.highlights = {};
        decisionPanelTitle.textContent = "Decision Process";
        const sortedInitial = [...initial].sort((a,b)=>a-b);
        save({ ...state, line: 10, msg: "Phase 4: Find best malware node to remove." });
        
        for (const node of sortedInitial) {
            const root = uf.find(node);
            state.highlights = { node: node, cell: { array: 'malware', index: root, op: 'read' } };
            state.decision.candidate = node;
            state.decision.malwareCount = state.malware[root];
            state.decision.size = state.size[root];
            save({ ...state, msg: `Considering removing malware at node ${node}.` });

            if (state.malware[root] === 1) {
                save({ ...state, line: 12, msg: `Component ${root} has only 1 malware. This is a valid candidate.` });
                if (state.size[root] > state.decision.maxSaved) {
                    state.decision.maxSaved = state.size[root];
                    state.decision.res = node;
                    save({ ...state, line: 13, msg: `This saves ${state.size[root]} nodes, a new maximum. Best node is now ${node}.` });
                } else {
                     save({ ...state, msg: `This saves ${state.size[root]} nodes, which is not better than ${state.decision.maxSaved}.` });
                }
            } else {
                save({ ...state, line: 12, msg: `Component ${root} has ${state.malware[root]} malware. Removing this one saves 0 nodes.` });
            }
        }
        state.highlights = {};
        const finalRes = state.decision.res === -1 ? sortedInitial[0] : state.decision.res;
        state.highlights.finalResultNode = finalRes;
        state.finalResult = finalRes;
        save({ ...state, line: 15, msg: `Decision complete. Best node to remove is ${finalRes}.` });
        
        return steps;
    }
    
    renderState(state) {
        actionDisplay.textContent = state.msg;
        document.querySelectorAll('.code-line').forEach(el => el.classList.remove('highlight'));
        if (state.line !== null) document.getElementById(`code-line-${state.line}`)?.classList.add('highlight');

        // Helper function to find root based on a parent array, for rendering.
        const findRootInState = (p_arr, i) => {
            if (p_arr[i] === i) return i;
            // No path compression during render, just find the root
            return findRootInState(p_arr, p_arr[i]);
        };
        
        if(graphDrawer) graphDrawer.draw(state, findRootInState);

        const renderArray = (arr, container, name) => {
            let html = `<h3>${name}</h3>`;
            for (let i = 0; i < arr.length; i++) {
                let cellClass = '';
                let valClass = '';
                if(state.highlights.cell && state.highlights.cell.array === name.toLowerCase() && state.highlights.cell.index === i){
                    valClass = state.highlights.cell.op;
                }
                if(findRootInState(state.parent, i) === i) cellClass = 'find'; // Highlight roots
                html += `<div class="array-cell ${cellClass}"><div class="idx">idx ${i}</div><div class="val ${valClass}">${arr[i] !== undefined ? arr[i] : '-'}</div></div>`;
            }
            container.innerHTML = html;
        };

        renderArray(state.parent, parentArrayContainer, 'Parent');
        renderArray(state.size, sizeArrayContainer, 'Size');
        renderArray(state.malware, malwareArrayContainer, 'Malware');

        if(state.phase === 'decision') {
            const {candidate, malwareCount, size, maxSaved, res} = state.decision;
            decisionContainer.innerHTML = `<div class="decision-panel">
                <div>Candidate: <span>${candidate !== null ? candidate : '-'}</span></div>
                <div>Malware in Component: <span class="${malwareCount === 1 ? 'good' : 'bad'}">${malwareCount !== null ? malwareCount : '-'}</span></div>
                <div>Component Size: <span>${size !== null ? size : '-'}</span></div>
                <hr>
                <div>Max Nodes Saved: <span>${maxSaved}</span></div>
                <div>Best Node So Far: <span>${res !== -1 ? res : 'None'}</span></div>
            </div>`;
        } else {
            decisionContainer.innerHTML = '';
        }

        if (state.finalResult !== null) {
            finalResultText.textContent = state.finalResult;
            resultModal.style.display = 'flex';
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    graphInput = document.getElementById('graph_input');
    initialInput = document.getElementById('initial_input');
    startButton = document.getElementById('start_button');
    nextStepButton = document.getElementById('next_step_button');
    codeContainer = document.getElementById('code_container');
    actionDisplay = document.getElementById('action_display');
    graphContainer = document.getElementById('graph_container');
    decisionContainer = document.getElementById('decision_container');
    decisionPanelTitle = document.getElementById('decision_panel_title');
    parentArrayContainer = document.getElementById('parent_array_container');
    sizeArrayContainer = document.getElementById('size_array_container');
    malwareArrayContainer = document.getElementById('malware_array_container');
    resultModal = document.getElementById('result_modal');
    finalResultText = document.getElementById('final_result_text');
    modalCloseBtn = document.getElementById('modal_close_btn');
    
    const anim = new MalwareAnimation();
    startButton.addEventListener('click', () => { if(simulationRunning) anim.reset(); else anim.start(); });
    nextStepButton.addEventListener('click', () => anim.next());
    modalCloseBtn.addEventListener('click', () => resultModal.style.display = 'none');
    resultModal.addEventListener('click', (e) => { if (e.target === resultModal) resultModal.style.display = 'none'; });
});
</script>
</body>
</html>