<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Search II Animation</title>
    <style>
        :root {
            --color-bg-light: #f4f7f6; --color-bg-panel: #ffffff; --color-text-dark: #2c3e50;
            --color-primary: #2c3e50; --color-success: #27ae60; --color-danger: #c0392b;
            --color-info: #3498db;
            --color-trie-node-stroke: #34495e; --color-trie-node-fill: #ffffff;
            --color-trie-node-end: var(--color-trie-node-stroke);
            --color-trie-path: #8e44ad;
            --color-board-path: #e67e22;
            --color-board-visited: #bdc3c7;
        }
        html, body {
            height: 100%; margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: var(--color-bg-light);
        }
        /* --- THE DEFINITIVE LAYOUT FIX --- */
        .dashboard-container {
            display: grid;
            grid-template-columns: minmax(480px, 1.2fr) 2fr minmax(380px, 0.9fr);
            grid-template-rows: auto 1fr;
            grid-template-areas:
                "header header header"
                "left main right";
            gap: 15px; padding: 15px; height: 100%; box-sizing: border-box;
        }
        .panel {
            background-color: var(--color-bg-panel); border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05); padding: 15px;
            display: flex; flex-direction: column;
            min-height: 0;
        }
        .left-column, .main-column, .right-column {
            min-height: 0;
            display: flex; flex-direction: column; gap: 15px;
        }
        /* --- END OF FIX --- */

        h1, h2, h3 { color: var(--color-text-dark); text-align: center; margin-top: 0; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid #eee;}
        h1 { font-size: 1.5em; border: none; } h2 { font-size: 1.1em; } h3 {font-size: 1em; text-align: left; border: none;}

        .header { grid-area: header; flex-shrink: 0; }
        .controls { display: flex; flex-wrap: wrap; gap: 15px; padding: 10px; background-color: #ecf0f1; border-radius: 5px; align-items: center; justify-content: center;}
        .controls label { font-weight: bold; }
        .controls input { padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-family: 'Courier New', monospace; }
        .controls input.words { width: 350px; }
        .controls .op-buttons button { padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; color: white; font-weight: bold;}
        .controls button.find { background-color: var(--color-success); }
        .controls .step-buttons button { padding: 10px 15px; background-color: var(--color-primary); color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; }
        .controls button:disabled { background-color: #bdc3c7; cursor: not-allowed; }
        
        .left-column .panel { flex: 1 1 auto; }
        .left-column .panel.fixed-height { flex: 0 0 auto; }

        #code_container, #result_container { background: #2d2d2d; color: #f1f1f1; font-family: 'Courier New', monospace; font-size: 0.9em; flex: 1; overflow-y: auto;}
        .code-line { padding: 2px 10px; border-radius: 3px; transition: background-color 0.3s; white-space: pre; }
        .code-line.highlight { background-color: #555; }
        #action_display { text-align: center; font-weight: bold; font-size: 1.1em; background: #f8f9fa; padding: 10px; border-radius: 4px; min-height: 48px; display: flex; align-items: center; justify-content: center; }
        
        #main_viz { height: 100%; display: flex; flex-direction: column; gap: 20px;}
        .board-grid { display: grid; gap: 5px; margin: 0 auto; }
        .board-cell { width: 40px; height: 40px; border: 1px solid #ccc; display: flex; align-items: center; justify-content: center; font-size: 1.2em; font-family: 'Courier New', monospace; transition: background-color 0.3s, border-color 0.3s; }
        .board-cell.start { border: 2px solid var(--color-info); }
        .board-cell.path { background-color: var(--color-board-path); color: white; border-color: var(--color-board-path); }
        .board-cell.visited { background-color: var(--color-board-visited); color: #7f8c8d; }
        #trie_viz_container { flex: 1; min-height: 0; }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <header class="header panel">
            <h1>Word Search II</h1>
            <div class="controls">
                <label>Words:</label> <input id="words_input" type="text" class="words" value="oath,pea,eat,rain">
                <div class="op-buttons"> <button id="find_button" class="find">Find Words</button> </div>
                <div class="step-buttons"> <button id="next_step_button" disabled>Next Step</button> <button id="reset_button">Reset</button> </div>
            </div>
        </header>

        <div class="left-column">
             <div class="panel">
                <h2>Java Implementation</h2>
                <div id="code_container"></div>
             </div>
             <div class="panel fixed-height">
                <h2>Current Action</h2>
                <div id="action_display">Enter words to search on the board.</div>
             </div>
        </div>

        <main class="main-column">
             <div class="panel" style="height: 100%;">
                <h2 id="main_viz_title">Visualization</h2>
                <div id="main_viz"></div>
             </div>
        </main>
        
        <div class="right-column">
            <div class="panel" style="height: 100%;">
                <h2>Found Words</h2>
                <div id="result_container"></div>
            </div>
        </div>
    </div>

<script>
let animationSteps = [], currentStepIndex = 0, simulationRunning = false;
let wordsInput, findButton, nextStepButton, resetButton,
    codeContainer, actionDisplay, mainVizTitle, mainViz, resultContainer;

const board = [
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
];

class WordSearchIIAnimation {
    constructor() { this.reset(); }
    
    reset() {
        this.clearAnimation();
        [mainViz, resultContainer].forEach(el => el.innerHTML = '');
        actionDisplay.textContent = 'Enter words and start the search.';
        mainVizTitle.textContent = 'Visualization';
    }
    
    clearAnimation() {
        animationSteps = []; currentStepIndex = 0; simulationRunning = false;
        this.updateButtons();
    }
    
    startOperation() {
        this.clearAnimation();
        const words = wordsInput.value.split(',').map(s => s.trim().toLowerCase()).filter(Boolean);
        if (words.length === 0) {
            alert("Please provide valid words."); return;
        }
        animationSteps = this.generateSteps(board, words);
        if (animationSteps.length > 0) {
            simulationRunning = true;
            this.renderState(animationSteps[0]);
            this.updateButtons();
        }
    }

    next() {
        if (!simulationRunning || currentStepIndex >= animationSteps.length - 1) return;
        currentStepIndex++;
        this.renderState(animationSteps[currentStepIndex]);
        this.updateButtons();
    }

    updateButtons() {
        findButton.disabled = simulationRunning;
        resetButton.disabled = simulationRunning;
        nextStepButton.disabled = !simulationRunning || currentStepIndex >= animationSteps.length - 1;
    }

    generateSteps(initialBoard, words) {
        const steps = [];
        let state = {
            phase: 'build', line: null, msg: '',
            trie: { children: {}, word: null, id: 0 },
            nodeIdCounter: 1, currentTriePath: [],
            board: JSON.parse(JSON.stringify(initialBoard)),
            result: [],
            startCell: null, dfsPath: []
        };
        const save = () => steps.push(JSON.parse(JSON.stringify(state)));

        state.line = 34; state.msg = 'Building Trie from dictionary.'; save();
        let trieRoot = state.trie;
        for (const word of words) {
            let node = trieRoot;
            state.currentTriePath = [node.id];
            state.line = 36; state.msg = `Adding word "${word}" to Trie.`; save();
            for (const char of word) {
                state.line = 40;
                if (!node.children[char]) {
                    node.children[char] = { children: {}, word: null, id: state.nodeIdCounter++ };
                    state.line = 41;
                }
                node = node.children[char];
                state.currentTriePath.push(node.id);
                 state.line = 43; save();
            }
            node.word = word;
            state.line = 45; state.msg = `Marked end of "${word}".`; save();
        }
        state.currentTriePath = [];
        
        state.phase = 'search'; state.line = 8; state.msg = 'Begin scanning the board.'; save();
        for (let i = 0; i < board.length; i++) {
            for (let j = 0; j < board[0].length; j++) {
                state.startCell = [i, j];
                state.line = 10; state.msg = `Starting DFS from board[${i}][${j}].`; save();
                generateDfsSteps(i, j, state.trie, state.board);
            }
        }
        state.startCell = null; state.line = 13; state.msg = 'Finished searching board.'; save();

        function generateDfsSteps(i, j, trieNode, boardState) {
            const char = boardState[i][j];
            state.line = 17; state.msg = `DFS at [${i}][${j}] ('${char}').`;
            state.dfsPath.push([i, j]);
            state.currentTriePath.push(trieNode.id);
            save();

            state.line = 18;
            if (char === '#' || !trieNode.children[char]) {
                state.msg = `Path blocked at [${i}][${j}]. Backtracking.`; save();
                state.dfsPath.pop(); state.currentTriePath.pop();
                return;
            }

            trieNode = trieNode.children[char];
            state.currentTriePath[state.currentTriePath.length - 1] = trieNode.id;
            state.line = 19; state.msg = `Character '${char}' found in Trie. Moving to next node.`; save();
            
            state.line = 20;
            if (trieNode.word) {
                state.result.push(trieNode.word);
                state.msg = `Found word: "${trieNode.word}"!`; state.line = 21; save();
                trieNode.word = null;
                state.msg = `Pruning word from Trie to avoid duplicates.`; state.line = 22; save();
            }

            boardState[i][j] = '#';
            state.board = JSON.parse(JSON.stringify(boardState));
            state.msg = `Marking [${i}][${j}] as visited.`; state.line = 24; save();

            const DIRS = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            state.line = 26;
            for (const [dx, dy] of DIRS) {
                const x = i + dx, y = j + dy;
                state.line = 27;
                if (x >= 0 && x < board.length && y >= 0 && y < board[0].length) {
                    state.msg = `Exploring neighbor at [${x}][${y}].`; save();
                    state.line = 28;
                    generateDfsSteps(x, y, trieNode, boardState);
                }
            }

            boardState[i][j] = char;
            state.board = JSON.parse(JSON.stringify(boardState));
            state.dfsPath.pop();
            state.currentTriePath.pop();
            state.msg = `Backtracking from [${i}][${j}], restoring '${char}'.`; state.line = 31; save();
        }
        return steps;
    }
    
    renderState(state) {
        document.querySelectorAll('.code-line').forEach(el => el.classList.remove('highlight'));
        if (state.line !== null) document.getElementById(`code-line-${state.line}`)?.classList.add('highlight');
        actionDisplay.textContent = state.msg;
        resultContainer.innerHTML = state.result.map(w => `<div>${w}</div>`).join('');

        if (state.phase === 'build') {
            mainVizTitle.textContent = 'Phase 1: Building Trie';
            mainViz.innerHTML = '<div id="trie_viz_container"><svg width="100%" height="100%"></svg></div>';
            const drawer = new TrieGraph(mainViz.querySelector('svg'));
            drawer.draw(state.trie, state.currentTriePath);
        } else {
            mainVizTitle.textContent = 'Phase 2: Searching Board';
            mainViz.innerHTML = `
                <div><h3>Board</h3><div class="board-grid"></div></div>
                <div id="trie_viz_container"><h3>Trie</h3><svg width="100%" height="100%"></svg></div>
            `;
            this.renderBoard(state);
            const drawer = new TrieGraph(mainViz.querySelector('svg'));
            drawer.draw(state.trie, state.currentTriePath);
        }
    }

    renderBoard(state) {
        const grid = mainViz.querySelector('.board-grid');
        grid.innerHTML = '';
        grid.style.gridTemplateColumns = `repeat(${state.board[0].length}, 45px)`;
        const pathSet = new Set(state.dfsPath.map(p => `${p[0]}-${p[1]}`));

        state.board.forEach((row, i) => {
            row.forEach((char, j) => {
                const cell = document.createElement('div');
                cell.className = 'board-cell';
                cell.textContent = char;
                if (char === '#') cell.classList.add('visited');
                if (pathSet.has(`${i}-${j}`)) cell.classList.add('path');
                if (state.startCell && state.startCell[0] === i && state.startCell[1] === j) {
                    cell.classList.add('start');
                }
                grid.appendChild(cell);
            });
        });
    }
}

class TrieGraph {
    constructor(svg) { this.svg = svg; }
    draw(trieRoot, path) {
        this.svg.innerHTML = ''; if (!trieRoot) return;
        const pathSet = new Set(path); const nodePositions = new Map(); const edges = [];
        const traverseAndPosition = (node, x, y, depth) => {
            if (!node || node.id === undefined) return;
            nodePositions.set(node.id, { x, y });
            const children = Object.entries(node.children).sort((a,b) => a[0].localeCompare(b[0]));
            const totalWidth = children.length * 50; let currentX = x - totalWidth / 2;
            children.forEach(([char, childNode]) => {
                const childX = currentX + 25; const childY = y + 60;
                edges.push({ from: node.id, to: childNode.id, char });
                traverseAndPosition(childNode, childX, childY, depth + 1);
                currentX += 50;
            });
        };
        const clientWidth = this.svg.parentElement.clientWidth || 600;
        traverseAndPosition(trieRoot, clientWidth / 2, 40, 0);
        edges.forEach(edge => {
            const fromPos = nodePositions.get(edge.from); const toPos = nodePositions.get(edge.to);
            if (!fromPos || !toPos) return;
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', fromPos.x); line.setAttribute('y1', fromPos.y);
            line.setAttribute('x2', toPos.x); line.setAttribute('y2', toPos.y);
            line.style.stroke = pathSet.has(edge.from) && pathSet.has(edge.to) ? 'var(--color-trie-path)' : '#ccc';
            line.style.strokeWidth = pathSet.has(edge.from) && pathSet.has(edge.to) ? 3 : 2;
            this.svg.appendChild(line);
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', (fromPos.x + toPos.x) / 2 - 4); text.setAttribute('y', (fromPos.y + toPos.y) / 2 + 5);
            text.textContent = edge.char; this.svg.appendChild(text);
        });
        const drawNodeRecursive = (node) => {
            if (!node || !nodePositions.has(node.id)) return;
            const pos = nodePositions.get(node.id);
            const g = this.createNodeElement(node, pos.x, pos.y, pathSet.has(node.id));
            this.svg.appendChild(g); Object.values(node.children).forEach(drawNodeRecursive);
        };
        drawNodeRecursive(trieRoot);
    }
    createNodeElement(node, x, y, isOnPath) {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${x},${y})`);
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('r', 15);
        circle.style.fill = node.word ? 'var(--color-trie-node-end)' : 'var(--color-trie-node-fill)';
        circle.style.stroke = isOnPath ? 'var(--color-trie-path)' : 'var(--color-trie-node-stroke)';
        circle.style.strokeWidth = 3; g.appendChild(circle); return g;
    }
}

document.addEventListener('DOMContentLoaded', () => {
    wordsInput = document.getElementById('words_input'); findButton = document.getElementById('find_button');
    nextStepButton = document.getElementById('next_step_button'); resetButton = document.getElementById('reset_button');
    codeContainer = document.getElementById('code_container'); actionDisplay = document.getElementById('action_display');
    mainVizTitle = document.getElementById('main_viz_title'); mainViz = document.getElementById('main_viz');
    resultContainer = document.getElementById('result_container');

    const code = [
        `class Solution {`,
        `  public List<String> findWords(...) {`,
        `3     List<String> res = new ArrayList<>();`,
        `4     TrieNode root = buildTrie(words);`,
        `5     int m = board.length, n = board[0].length;`,
        `6     `,
        `7     // Start search from every cell`,
        `8     for (int i = 0; i < m; i++) {`,
        `9         for (int j = 0; j < n; j++) {`,
        `10            dfs(board, i, j, root, res);`,
        `11        }`,
        `12    }`,
        `13    return res;`,
        `14 }`,
        ``,
        `16 private void dfs(board, i, j, node, res) {`,
        `17    char c = board[i][j];`,
        `18    if (c == '#' || node.children[c-'a'] == null) return;`,
        `19    node = node.children[c - 'a'];`,
        `20    if (node.word != null) {`,
        `21        res.add(node.word);`,
        `22        node.word = null; // avoid duplicates`,
        `23    }`,
        `24    board[i][j] = '#';`,
        `25    // Explore neighbors`,
        `26    for (all 4 directions) {`,
        `27        if (neighbor is valid) {`,
        `28            dfs(board, x, y, node, res);`,
        `29        }`,
        `30    }`,
        `31    board[i][j] = c; // backtrack`,
        `32 }`,
        ``,
        `34 private TrieNode buildTrie(String[] words) {`,
        `35    TrieNode root = new TrieNode();`,
        `36    for (String word : words) {`,
        `37        TrieNode node = root;`,
        `38        for (char c : word.toCharArray()) {`,
        `39            int idx = c - 'a';`,
        `40            if (node.children[idx] == null) {`,
        `41                node.children[idx] = new TrieNode();`,
        `42            }`,
        `43            node = node.children[idx];`,
        `44        }`,
        `45        node.word = word;`,
        `46    }`,
        `47    return root;`,
        `48 }`,
        `}`
    ].map((line, i) => `<div class="code-line" id="code-line-${i}">${line.replace(/ /g, '&nbsp;')}</div>`).join('');
    codeContainer.innerHTML = code;
    
    const anim = new WordSearchIIAnimation();
    findButton.addEventListener('click', () => anim.startOperation());
    nextStepButton.addEventListener('click', () => anim.next());
    resetButton.addEventListener('click', () => anim.reset());
});
</script>
</body>
</html>