<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimum Cost to Connect Sticks Animation</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f7f6;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            width: 95%;
            max-width: 900px;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 15px;
        }
        h2 {
            font-size: 1.1em;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
            margin-top: 10px;
        }

        .controls {
            display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; padding: 15px;
            background-color: #e8f0fe; border-radius: 5px; align-items: center; justify-content: center;
        }
        .controls label { font-weight: bold; margin-right: 5px; }
        .controls input { padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 250px; }
        .controls button {
            padding: 10px 15px; background-color: #3498db; color: white;
            border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s ease;
        }
        .controls button:hover { background-color: #2980b9; }
        .controls button:disabled { background-color: #bdc3c7; cursor: not-allowed; }

        .visualization-area-mcs {
            display: grid;
            grid-template-columns: 1fr; /* Single column for simplicity */
            gap: 20px;
            margin-bottom: 20px;
        }
        .sticks-display-mcs, .heap-display-mcs, .operation-display-mcs, .cost-display-mcs {
            padding: 15px; background-color: #fdfdfd;
            border: 1px solid #e0e0e0; border-radius: 5px;
        }
        
        .sticks-initial-area, .heap-area-mcs, .connecting-sticks-area-mcs {
            min-height: 60px;
            padding: 10px;
            border: 1px dashed #ccc;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            justify-content: center; /* Center items */
        }
        .heap-area-mcs { border-color: #27ae60; background-color: #e8f8f5; } /* Greenish for MinHeap */
        .connecting-sticks-area-mcs { border-color: #f39c12; background-color: #fef9e7; min-height: 70px;}


        .stick-item-mcs, .heap-entry-mcs {
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 1em;
            font-weight: bold;
            text-align: center;
            border: 1px solid #bdc3c7;
            background-color: #ecf0f1;
            transition: background-color 0.3s ease, transform 0.4s ease, opacity 0.4s ease;
            min-width: 40px; /* Ensure some width */
        }
        .heap-entry-mcs { background-color: #a9dfbf; border-color: #7dcea0; }
        
        /* Highlighting States */
        .stick-item-mcs.current-add-to-heap { background-color: #f1c40f; transform: scale(1.1); }
        .heap-entry-mcs.polling-stick1 { background-color: #f5b041; border-color: #f39c12; transform:translateX(-15px) scale(1.1); }
        .heap-entry-mcs.polling-stick2 { background-color: #f5b041; border-color: #f39c12; transform:translateX(15px) scale(1.1); }
        .heap-entry-mcs.newly-combined { background-color: #82e0aa; border-color: #2ecc71; animation: popInStick 0.5s; }
        .heap-entry-mcs.fading-out { opacity: 0; transform: scale(0.5); }


        @keyframes popInStick { from {transform: scale(0.5); opacity:0;} to {transform: scale(1); opacity:1;} }

        #total_cost_mcs { font-size: 1.4em; font-weight: bold; color: #e74c3c; }
        #current_action_mcs { text-align:center; margin-bottom:10px; font-weight:bold; min-height:1.2em; color: #2980b9;}
        .log-container-mcs { background-color: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 5px; margin-top: 10px; }
        #log_output_mcs { white-space: pre-wrap; word-wrap: break-word; max-height: 150px; overflow-y: auto; font-family: 'Courier New', Courier, monospace; font-size: 0.9em; }
    </style>
</head>
<body>
    <div class="container">
        <p class="no-print"><a href="../patterns/heap_cheatsheet.html">‚Üê Back to Heap Pattern</a></p>

        <h1>Minimum Cost to Connect Sticks Animation</h1>

        <div class="controls">
            <label for="sticks_input_mcs">Sticks (comma-separated lengths):</label>
            <input type="text" id="sticks_input_mcs" value="2,4,3">
            <button id="start_button_mcs">Start/Reset</button>
            <button id="next_step_button_mcs" disabled>Next Step</button>
        </div>

        <div class="visualization-area-mcs">
            <div class="sticks-display-mcs">
                <h2>Initial Sticks</h2>
                <div id="initial_sticks_area_mcs" class="sticks-initial-area"></div>
            </div>
            <div class="heap-display-mcs">
                <h2>Min-Heap (Stick Lengths)</h2>
                <div id="heap_area_mcs" class="heap-area-mcs"></div>
            </div>
            <div class="operation-display-mcs">
                <h2>Currently Connecting</h2>
                <div id="connecting_sticks_area_mcs" class="connecting-sticks-area-mcs"></div>
            </div>
            <div class="cost-display-mcs" style="text-align:center;">
                <h2>Total Cost</h2>
                <div id="total_cost_mcs">0</div>
            </div>
        </div>
        
        <div id="current_action_mcs"></div>
        <div class="log-container-mcs">
            <h2>Log</h2>
            <pre id="log_output_mcs"></pre>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const sticksInput = document.getElementById('sticks_input_mcs');
        const startButton = document.getElementById('start_button_mcs');
        const nextStepButton = document.getElementById('next_step_button_mcs');

        const initialSticksArea = document.getElementById('initial_sticks_area_mcs');
        const heapArea = document.getElementById('heap_area_mcs');
        const connectingSticksArea = document.getElementById('connecting_sticks_area_mcs');
        const totalCostDisplay = document.getElementById('total_cost_mcs');
        const currentActionDisplay = document.getElementById('current_action_mcs');
        const logOutput = document.getElementById('log_output_mcs');

        const ANIMATION_DELAY = 800;
        const SHORT_DELAY = 400;

        let initialSticksData = [];
        let minHeapData = []; // Array of numbers (stick lengths)
        let totalCost = 0;
        
        let animationStep = 0; // 0: init, 1: populating heap, 2: main connection loop
        let heapPopulationIdx = 0;
        let polledStick1 = null, polledStick2 = null; // For animation state

        function logMCS(message) {
            logOutput.innerHTML += `> ${message}\n`;
            logOutput.scrollTop = logOutput.scrollHeight;
        }

        function clearHighlightsAndActions() {
            connectingSticksArea.innerHTML = ''; // Clear connecting area
            // More specific highlight removal can be added if needed for heap elements
            currentActionDisplay.textContent = '';
        }

        function renderInitialSticks() {
            initialSticksArea.innerHTML = '';
            initialSticksData.forEach((length, index) => {
                const item = document.createElement('div');
                item.classList.add('stick-item-mcs');
                item.id = `init-stick-${index}`;
                item.textContent = length;
                initialSticksArea.appendChild(item);
            });
        }

        function renderMinHeap() {
            heapArea.innerHTML = '';
            // Min-heap: sort numerically ascending
            minHeapData.sort((a, b) => a - b); 
            
            minHeapData.forEach((length, index) => {
                const item = document.createElement('div');
                item.classList.add('heap-entry-mcs');
                item.id = `heap-entry-${length}-${index}`; // Attempt at unique ID
                item.textContent = length;
                heapArea.appendChild(item);
            });
        }

        async function addToHeapVisual(length, isCombined = false) {
            minHeapData.push(length);
            renderMinHeap(); // Sorts and renders

            // Find the newly added element to animate it
            // This is tricky if there are duplicate lengths. We'll animate the last one for simplicity.
            const heapEntries = heapArea.querySelectorAll('.heap-entry-mcs');
            let newEntryEl = null;
            for(let i = heapEntries.length -1; i>=0; i--){ // Search from end as sort puts it there
                if(parseInt(heapEntries[i].textContent) === length) {
                    let alreadyAnimated = false; // Try to avoid re-animating existing similar values if possible
                    // A more robust way would be to assign unique IDs to sticks.
                    // For this visual, finding the last one that matches is usually good enough.
                    if (!heapEntries[i].classList.contains('newly-combined') && !heapEntries[i].classList.contains('polling-stick1') && !heapEntries[i].classList.contains('polling-stick2')){
                         newEntryEl = heapEntries[i];
                         break;
                    }
                }
            }
             if (!newEntryEl && heapEntries.length > 0 && parseInt(heapEntries[0].textContent) === length) {
                // Fallback for single element or if it became the new minimum
                newEntryEl = heapEntries[0];
            }


            if (newEntryEl) {
                if (isCombined) {
                    newEntryEl.classList.add('newly-combined'); // Uses popInStick animation
                } else { // Initial population
                    newEntryEl.style.transform = 'scale(0.5)';
                    newEntryEl.style.opacity = '0';
                    await new Promise(r => setTimeout(r, 50)); 
                    newEntryEl.style.transform = 'scale(1)';
                    newEntryEl.style.opacity = '1';
                }
                await new Promise(r => setTimeout(r, ANIMATION_DELAY / 1.5));
                // newEntryEl.classList.remove('newly-combined'); // Animation is one-shot
            }
        }

        async function pollFromHeapVisual(isStick1) {
            if (minHeapData.length === 0) return null;
            minHeapData.sort((a, b) => a - b); // Ensure sorted
            const length = minHeapData.shift(); // Remove from internal data

            // Find the DOM element to animate (the first one, as it's a min-heap)
            const heapEntries = heapArea.querySelectorAll('.heap-entry-mcs');
            if (heapEntries.length > 0 && parseInt(heapEntries[0].textContent) === length) {
                const polledEl = heapEntries[0];
                polledEl.classList.add(isStick1 ? 'polling-stick1' : 'polling-stick2');
                await new Promise(r => setTimeout(r, ANIMATION_DELAY / 1.5));
                polledEl.classList.add('fading-out');
                await new Promise(r => setTimeout(r, ANIMATION_DELAY / 2));
            }
            renderMinHeap(); // Re-render PQ display without the polled item
            return length;
        }

        function updateTotalCostVisual() {
            totalCostDisplay.textContent = totalCost;
            totalCostDisplay.style.transform = 'scale(1.2)';
            totalCostDisplay.style.transition = 'transform 0.2s ease-out';
            setTimeout(() => { totalCostDisplay.style.transform = 'scale(1)'; }, 200);
        }


        async function initializeAnimation() {
            logMCS("Initializing...");
            clearHighlightsAndActions();
            try {
                initialSticksData = sticksInput.value.split(',')
                                     .map(s => parseInt(s.trim()))
                                     .filter(n => !isNaN(n) && n > 0);
            } catch (e) {
                alert("Invalid sticks input. Use comma-separated positive numbers.");
                return;
            }

            if (initialSticksData.length === 0) {
                logMCS("No sticks to connect.");
                totalCostDisplay.textContent = "0";
                startButton.textContent = "Start/Reset";
                nextStepButton.disabled = true;
                return;
            }

            minHeapData = [];
            totalCost = 0;
            animationStep = 1; // Start with populating heap
            heapPopulationIdx = 0;
            polledStick1 = null; polledStick2 = null;

            renderInitialSticks();
            renderMinHeap();
            updateTotalCostVisual();
            
            startButton.textContent = "Reset";
            nextStepButton.disabled = false;
            logMCS("Initialized. Click 'Next Step' to populate Min-Heap.");
        }

        async function nextStep() {
            nextStepButton.disabled = true; 
            clearHighlightsAndActions();

            if (animationStep === 1) { // Populating Min-Heap
                if (heapPopulationIdx < initialSticksData.length) {
                    const stickLength = initialSticksData[heapPopulationIdx];
                    currentActionDisplay.textContent = `Adding stick of length ${stickLength} to Min-Heap.`;
                    logMCS(`Heap: Adding ${stickLength}`);
                    
                    const initialStickEl = document.getElementById(`init-stick-${heapPopulationIdx}`);
                    if (initialStickEl) initialStickEl.classList.add('current-add-to-heap');
                    
                    await addToHeapVisual(stickLength, false);
                    
                    if (initialStickEl) initialStickEl.classList.remove('current-add-to-heap');
                    heapPopulationIdx++;

                    if (heapPopulationIdx < initialSticksData.length) {
                        nextStepButton.disabled = false;
                    } else {
                        animationStep = 2; 
                        logMCS("Min-Heap populated. Click 'Next Step' to connect sticks.");
                        currentActionDisplay.textContent = "Heap populated. Ready to connect.";
                        nextStepButton.disabled = false;
                    }
                }
            } else if (animationStep === 2) { // Main connection loop
                if (minHeapData.length <= 1) {
                    currentActionDisplay.textContent = "Process complete. Final cost calculated.";
                    logMCS("Only one (or zero) stick left in heap. Process finished.");
                    animationStep = 3; // Done
                    nextStepButton.disabled = true;
                    startButton.textContent = "Start/Reset";
                    if(minHeapData.length === 1) {
                        logMCS(`Final combined stick: ${minHeapData[0]}`);
                    }
                    return;
                }

                // Poll stick1
                currentActionDisplay.textContent = "Polling shortest stick (stick1)...";
                polledStick1 = await pollFromHeapVisual(true);
                if (polledStick1 === null) { animationStep = 3; nextStepButton.disabled = true; return; } // Should not happen if size > 1
                logMCS(`Polled stick1: ${polledStick1}`);
                const stick1El = document.createElement('div');
                stick1El.classList.add('heap-entry-mcs'); // Use heap-entry style for consistency
                stick1El.textContent = polledStick1;
                connectingSticksArea.appendChild(stick1El);
                currentActionDisplay.textContent = `Polled stick1: ${polledStick1}. Polling stick2...`;
                await new Promise(r => setTimeout(r, SHORT_DELAY));


                // Poll stick2
                polledStick2 = await pollFromHeapVisual(false);
                if (polledStick2 === null) { animationStep = 3; nextStepButton.disabled = true; return; }
                logMCS(`Polled stick2: ${polledStick2}`);
                const stick2El = document.createElement('div');
                stick2El.classList.add('heap-entry-mcs');
                stick2El.textContent = polledStick2;
                connectingSticksArea.appendChild(stick2El);
                currentActionDisplay.textContent = `Connecting ${polledStick1} and ${polledStick2}.`;
                await new Promise(r => setTimeout(r, ANIMATION_DELAY));

                // Calculate cost and new stick
                const currentCost = polledStick1 + polledStick2;
                totalCost += currentCost;
                const newCombinedStick = currentCost; // Length of new stick is the cost of this connection

                logMCS(`Cost of this connection: ${currentCost}. New Total Cost: ${totalCost}.`);
                logMCS(`New combined stick of length ${newCombinedStick} formed.`);
                currentActionDisplay.textContent = `Cost: ${currentCost}. Total: ${totalCost}. New stick: ${newCombinedStick}.`;
                updateTotalCostVisual();

                // Visually "merge"
                connectingSticksArea.innerHTML = ''; // Clear individual sticks
                const combinedEl = document.createElement('div');
                combinedEl.classList.add('heap-entry-mcs', 'newly-combined'); // Style as if it's from heap
                combinedEl.textContent = newCombinedStick;
                connectingSticksArea.appendChild(combinedEl); // Show combined stick briefly
                await new Promise(r => setTimeout(r, ANIMATION_DELAY));


                // Add new stick to heap
                currentActionDisplay.textContent = `Adding combined stick ${newCombinedStick} back to heap.`;
                logMCS(`Adding combined stick ${newCombinedStick} to heap.`);
                await addToHeapVisual(newCombinedStick, true);
                connectingSticksArea.innerHTML = ''; // Clear combined stick from connecting area
                
                polledStick1 = null; polledStick2 = null;
                
                if (minHeapData.length > 1) {
                    nextStepButton.disabled = false;
                } else {
                    currentActionDisplay.textContent = "Process complete. Final cost calculated.";
                    logMCS("Only one stick left. Process finished.");
                    animationStep = 3;
                    nextStepButton.disabled = true;
                    startButton.textContent = "Start/Reset";
                }
            }
        }

        startButton.addEventListener('click', initializeAnimation);
        nextStepButton.addEventListener('click', nextStep);
        initializeAnimation(); 
    });
    </script>
</body>
</html>