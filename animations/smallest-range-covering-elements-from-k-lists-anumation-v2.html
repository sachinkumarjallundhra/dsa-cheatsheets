<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smallest Range Covering K Lists Animation (with Timeline)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex; flex-direction: column; align-items: center;
            margin-top: 15px; background-color: #eef1f5; color: #333; line-height: 1.6;
        }
        .container {
            background-color: #fff; padding: 20px; border-radius: 12px;
            box-shadow: 0 6px 25px rgba(0,0,0,0.1); width: 95%; max-width: 1200px;
        }
        h1, h2, h3 { color: #2c3e50; margin-top: 0; text-align: center; }
        h3 { margin-bottom: 8px; font-size: 1.05em; text-align: left;}
        h4 { margin-top: 5px; margin-bottom: 5px; font-size: 1em; color: #495057;}

        .controls { /* ... (same as before) ... */
            display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; align-items: center;
            padding: 15px; background-color: #f8f9fa; border-radius: 8px; border: 1px solid #dce4ec;
        }
        .controls label { margin-right: 3px; font-size: 0.9em;}
        .controls textarea { padding: 8px; border-radius: 5px; border: 1px solid #ced4da; font-size:0.9em; width: 100%; min-height: 60px; box-sizing: border-box;}
        .controls button {
            padding: 9px 16px; border: none; border-radius: 5px; cursor: pointer;
            background-color: #007bff; color: white; font-size: 0.9em;
            transition: background-color 0.2s ease;
        }
        .controls button:hover { background-color: #0056b3; }
        .controls button:disabled { background-color: #adb5bd; cursor: not-allowed; }
        
        .main-layout { display: grid; grid-template-columns: 1.5fr 1fr; gap: 20px; margin-bottom: 15px; }
        .input-lists-section, .process-visualization-section {
            padding: 15px; border: 1px solid #dce4ec; border-radius: 8px; background-color: #fdfdff;
        }

        .list-display-container { margin-bottom: 8px; }
        .list-label { font-weight: bold; margin-right: 5px; display: inline-block; min-width:50px;}
        .block-array { display: flex; flex-wrap: wrap; gap: 5px; min-height: 38px; padding: 3px 0; }
        .element-block { /* ... (same as before) ... */
            padding: 7px 10px; border: 1px solid #6c757d; border-radius: 4px;
            background-color: #e9ecef; color: #495057;
            font-weight: bold; text-align: center;
            transition: all 0.3s ease; box-shadow: 0 1px 2px rgba(0,0,0,0.05); min-width: 30px;
        }
        .heap-item-display { /* ... (same as before) ... */
            background-color: #ffe8cc; border-color: #ffd3a0; color: #8c5a20; 
            padding: 6px 9px; margin: 4px 3px; border: 1px solid; border-radius: 4px;
            font-size: 0.8em; display: inline-block; font-weight: bold;
        }
        #heap-container { min-height: 40px; display: flex; flex-wrap: wrap; align-content: flex-start; gap: 4px;}

        .metrics-display div { margin-bottom: 6px; font-size: 0.95em;}
        .metrics-display span { font-weight: bold; color: #007bff; }
        .highlight-text { color: #dc3545 !important; font-weight: bolder; }
        .highlight-range-update { background-color: #d1e7dd; padding: 2px 5px; border-radius: 3px;}

        .highlight-current-list-element { background-color: #a0d2eb !important; border-color: #62b3c9 !important; transform: scale(1.1); }
        .highlight-heap-item-pre-pop { background-color: #ffc107 !important; border-color: #ffaa00 !important; box-shadow: 0 0 8px #ffc107 !important; transform: scale(1.08); }
        .highlight-heap-item-add { background-color: #c3e6cb !important; border-color: #80b78a !important; transform: scale(1.05); }
        
        /* Timeline Styles */
        #timeline-section { grid-column: 1 / -1; /* Span full width */ }
        #timeline-container {
            width: 100%;
            height: 60px; /* Adjust as needed */
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 5px;
            position: relative;
            margin-top: 10px;
            overflow: hidden;
        }
        .timeline-tick {
            position: absolute;
            bottom: 0;
            width: 2px; /* Width of the tick mark */
            height: 15px; /* Height of the tick mark */
            background-color: #aaa;
        }
        .timeline-tick-label {
            position: absolute;
            bottom: 18px; /* Position label above tick */
            font-size: 0.7em;
            color: #555;
            transform: translateX(-50%); /* Center label on tick */
            white-space: nowrap;
        }
        .timeline-range-marker {
            position: absolute;
            height: 100%;
            top: 0;
            opacity: 0.3;
            transition: left 0.3s ease-out, width 0.3s ease-out;
        }
        #timeline-current-range { background-color: #79c7e3; z-index: 1;} /* Light blue */
        #timeline-smallest-range { background-color: #77dd77; z-index: 2;} /* Light green */
        
        .timeline-pointer {
            position: absolute;
            bottom: 0;
            height: 100%;
            width: 3px; /* Thicker line for pointers */
            transition: left 0.3s ease-out;
            z-index: 3;
        }
        #timeline-min-pointer { background-color: #6f42c1; /* Purple */ }
        #timeline-max-pointer { background-color: #fd7e14; /* Orange */ }


        #status-message { margin-top: 15px; font-style: italic; color: #495057; min-height: 22px; text-align: center;}
        .pseudo-code-container { margin-top: 20px; }
        .pseudo-code { /* ... (same as before) ... */
            padding: 15px; background-color: #2c3e50; color: #ecf0f1;
            border-radius: 8px; text-align: left; font-family: 'Consolas', 'Courier New', monospace;
            white-space: pre; font-size: 0.85em; line-height: 1.7; max-height: 400px; overflow-y: auto;
        }
        .pseudo-code .line { padding: 2px 5px; border-radius: 3px; transition: background-color 0.3s ease; }
        .pseudo-code .highlight-code { background-color: #3498db; color: white; display: block; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Smallest Range Covering K Lists (with Timeline)</h1>

        <div class="controls">
            <label for="lists-input">Input K Sorted Lists (one list per line, comma-separated numbers):</label>
            <textarea id="lists-input" rows="3">4,10,15,24,26&#10;0,9,12,20&#10;5,18,22,30</textarea>
            <button id="reset-btn">Reset</button>
            <button id="next-step-btn">Next Step</button>
            <button id="auto-play-btn">Auto Play</button>
            <label for="speed-slider">Speed:</label>
            <input type="range" id="speed-slider" min="100" max="2000" value="1000" step="100">
        </div>

        <div class="main-layout">
            <div class="input-lists-section">
                <h3>Input K Sorted Lists (K = <span id="k-value-display"></span>):</h3>
                <div id="input-lists-master-container"></div>
            </div>
            <div class="process-visualization-section">
                <h3>Min-Heap (Value, ListIdx, ElementIdx):</h3>
                <div id="heap-container"></div>
                <div class="metrics-display" style="margin-top: 15px;">
                    <h4>Current State:</h4>
                    <div>Max element currently in heap's scope: <span id="current-max-in-heap">-</span></div>
                    <div>Current range considered: <span id="current-range-considered">[-]</span></div>
                    <h4 style="margin-top:10px;">Best Found:</h4>
                    <div>Smallest range: <span id="smallest-range-found">[-,-]</span> (Length: <span id="smallest-range-length">Infinity</span>)</div>
                </div>
            </div>
        </div>

        <div class="data-section" id="timeline-section">
            <h3>Overall Number Timeline & Ranges:</h3>
            <div id="timeline-container">
                <div id="timeline-current-range" class="timeline-range-marker"></div>
                <div id="timeline-smallest-range" class="timeline-range-marker"></div>
                <div id="timeline-min-pointer" class="timeline-pointer"></div>
                <div id="timeline-max-pointer" class="timeline-pointer"></div>
            </div>
        </div>

        <div id="status-message">Enter lists, then click Reset.</div>
        <div class="pseudo-code-container">
             <!-- Pseudo-code (same as before) -->
            <h3>Algorithm Steps:</h3>
            <div class="pseudo-code">
<div class="line" id="code-0">Initialize min_heap, current_max_in_heap = -INF</div>
<div class="line" id="code-1">range_start = 0, range_end = INF</div>
<div class="line" id="code-2">For list_idx from 0 to k-1: // Initial heap population</div>
<div class="line" id="code-3">&nbsp;&nbsp;If lists[list_idx] is not empty:</div>
<div class="line" id="code-4">&nbsp;&nbsp;&nbsp;&nbsp;element_val = lists[list_idx][0]</div>
<div class="line" id="code-5">&nbsp;&nbsp;&nbsp;&nbsp;heap.push( (element_val, list_idx, 0) )</div>
<div class="line" id="code-6">&nbsp;&nbsp;&nbsp;&nbsp;current_max_in_heap = max(current_max_in_heap, element_val)</div>
<div class="line" id="code-7">While true (loop until a list is exhausted):</div>
<div class="line" id="code-8">&nbsp;&nbsp;Peek min_item from heap. Highlight it.</div>
<div class="line" id="code-9">&nbsp;&nbsp;min_val_popped, list_idx, element_idx = heap.pop().</div>
<div class="line" id="code-10">&nbsp;&nbsp;If (current_max_in_heap - min_val_popped < range_end - range_start) OR ... :</div>
<div class="line" id="code-11">&nbsp;&nbsp;&nbsp;&nbsp;range_start = min_val_popped; range_end = current_max_in_heap.</div>
<div class="line" id="code-12">&nbsp;&nbsp;next_element_idx = element_idx + 1.</div>
<div class="line" id="code-13">&nbsp;&nbsp;If next_element_idx < lists[list_idx].length:</div>
<div class="line" id="code-14">&nbsp;&nbsp;&nbsp;&nbsp;next_val = lists[list_idx][next_element_idx].</div>
<div class="line" id="code-15">&nbsp;&nbsp;&nbsp;&nbsp;heap.push( (next_val, list_idx, next_element_idx) ).</div>
<div class="line" id="code-16">&nbsp;&nbsp;&nbsp;&nbsp;current_max_in_heap = max(current_max_in_heap, next_val).</div>
<div class="line" id="code-17">&nbsp;&nbsp;Else: // List exhausted</div>
<div class="line" id="code-18">&nbsp;&nbsp;&nbsp;&nbsp;Break loop.</div>
<div class="line" id="code-19">Return [range_start, range_end].</div>
            </div>
        </div>
    </div>

<script>
    // DOM Elements (add timeline elements)
    const listsInputEl = document.getElementById('lists-input');
    const resetBtn = document.getElementById('reset-btn');
    // ... (other controls same as before) ...
    const timelineContainer = document.getElementById('timeline-container');
    const timelineCurrentRangeEl = document.getElementById('timeline-current-range');
    const timelineSmallestRangeEl = document.getElementById('timeline-smallest-range');
    const timelineMinPointerEl = document.getElementById('timeline-min-pointer');
    const timelineMaxPointerEl = document.getElementById('timeline-max-pointer');
    const speedSlider = document.getElementById('speed-slider'); // ensure this is defined
    const kValueDisplay = document.getElementById('k-value-display'); // ensure this is defined
    const inputListsMasterContainer = document.getElementById('input-lists-master-container'); // ensure
    const heapContainer = document.getElementById('heap-container'); // ensure
    const currentMaxInHeapDisplay = document.getElementById('current-max-in-heap'); // ensure
    const currentRangeConsideredDisplay = document.getElementById('current-range-considered'); // ensure
    const smallestRangeFoundDisplay = document.getElementById('smallest-range-found'); // ensure
    const smallestRangeLengthDisplay = document.getElementById('smallest-range-length'); // ensure
    const statusMessage = document.getElementById('status-message'); // ensure
    const nextStepBtn = document.getElementById('next-step-btn'); // ensure
    const autoPlayBtn = document.getElementById('auto-play-btn'); // ensure


    // State
    let animationSpeed = 1000;
    let isAutoPlaying = false;
    // ... (other state vars same) ...
    let kLists = []; 
    let allUniqueSortedNumbers = []; // For timeline scale
    let timelineScaleMin = 0;
    let timelineScaleMax = 1;


    // MinHeap class (same as before)
    class MinHeap {
        constructor() { this.heap = []; }
        push(item) {
            item.key = `L${item.listIdx}-E${item.elementIdxInList}-${Date.now()}${Math.random().toString(36).substr(2,5)}`;
            this.heap.push(item);
            this.heap.sort((a, b) => a.val - b.val || a.listIdx - b.listIdx || a.elementIdxInList - b.elementIdxInList);
        }
        pop() { return this.heap.shift(); }
        peek() { return this.heap.length > 0 ? this.heap[0] : null; }
        isEmpty() { return this.heap.length === 0; }
        size() { return this.heap.length; } 
        clear() { this.heap = []; }
        getElements() { return [...this.heap]; }
    }
    const minHeap = new MinHeap();

    // --- Rendering Functions ---
    // renderInputLists, renderHeap, updateMetricsDisplays, highlightCodeLine (mostly same)
    function renderInputLists(lists, highlightInfo = null) { /* ... (same) ... */
        inputListsMasterContainer.innerHTML = '';
        lists.forEach((list, listIndex) => {
            const listDiv = document.createElement('div');
            listDiv.className = 'list-display-container';
            
            const labelSpan = document.createElement('span');
            labelSpan.className = 'list-label';
            labelSpan.textContent = `List ${listIndex}:`;
            listDiv.appendChild(labelSpan);

            const arrayDiv = document.createElement('div');
            arrayDiv.className = 'block-array';
            arrayDiv.id = `input-list-${listIndex}`;
            
            list.forEach((val, elementIndex) => {
                const elBlock = document.createElement('div');
                elBlock.className = 'element-block';
                elBlock.textContent = val;
                elBlock.id = `el-L${listIndex}-E${elementIndex}`;
                if (highlightInfo && highlightInfo.listIdx === listIndex && highlightInfo.elementIdx === elementIndex) {
                    if (highlightInfo.type === 'current_max') elBlock.classList.add('highlight-current-max');
                    else if (highlightInfo.type === 'popped_min') elBlock.classList.add('highlight-popped-min');
                    else if (highlightInfo.type === 'next_candidate') elBlock.classList.add('highlight-current-list-element');
                }
                arrayDiv.appendChild(elBlock);
            });
            listDiv.appendChild(arrayDiv);
            inputListsMasterContainer.appendChild(listDiv);
        });
    }

    function renderHeap(heapElements, action = null, itemKey = null) { /* ... (same) ... */
        heapContainer.innerHTML = '';
        heapElements.forEach(item => {
            const el = document.createElement('div');
            el.className = 'heap-item-display';
            el.id = `heap-${item.key}`;
            el.textContent = `${item.val} (L${item.listIdx},E${item.elementIdxInList})`;
            if (item.key === itemKey) {
                if (action === 'PRE_POP') el.classList.add('highlight-heap-item-pre-pop');
                else if (action === 'ADD') el.classList.add('highlight-heap-item-add');
            }
            heapContainer.appendChild(el);
             if (item.key === itemKey && action === 'ADD') {
                setTimeout(() => el.classList.remove('highlight-heap-item-add'), animationSpeed * 0.7);
            }
        });
    }
    
    function updateMetricsDisplays(currentMax, currentRange, smallestRange, smallestLength, rangeUpdated = false) { /* ... (same) ... */
        currentMaxInHeapDisplay.textContent = currentMax === -Infinity || currentMax === Infinity ? '-' : currentMax;
        currentRangeConsideredDisplay.textContent = currentRange ? `[${currentRange[0]}, ${currentRange[1]}] (Len: ${currentRange[1]-currentRange[0]})` : '[-]';
        
        smallestRangeFoundDisplay.classList.remove('highlight-range-update');
        smallestRangeFoundDisplay.textContent = smallestRange ? `[${smallestRange[0]}, ${smallestRange[1]}]` : '[-,-]';
        smallestRangeLengthDisplay.textContent = smallestLength === Infinity ? 'Infinity' : smallestLength;
        if (rangeUpdated) {
            void smallestRangeFoundDisplay.offsetWidth; // Trigger reflow
            smallestRangeFoundDisplay.classList.add('highlight-range-update');
        }
    }
    function highlightCodeLine(lineId) { /* ... (same) ... */
        document.querySelectorAll('.pseudo-code .line').forEach(l => l.classList.remove('highlight-code'));
        if (lineId) document.getElementById(lineId)?.classList.add('highlight-code');
    }


    function renderTimeline(allNums, scaleMin, scaleMax, currentRange = null, smallestRange = null, minPtrVal = null, maxPtrVal = null) {
        timelineContainer.innerHTML = ''; // Clear previous ticks and markers, but keep range/pointer elements for transition
        
        // Re-add persistent markers for transition
        timelineContainer.appendChild(timelineCurrentRangeEl);
        timelineContainer.appendChild(timelineSmallestRangeEl);
        timelineContainer.appendChild(timelineMinPointerEl);
        timelineContainer.appendChild(timelineMaxPointerEl);

        const timelineWidth = timelineContainer.offsetWidth;
        const rangeOfScale = scaleMax - scaleMin;

        if (rangeOfScale <= 0) return; // Avoid division by zero if all numbers are same or no numbers

        // Draw ticks and labels
        const numTicks = Math.min(allNums.length, 20); // Limit ticks for readability
        const step = Math.max(1, Math.floor(allNums.length / numTicks));

        for (let i = 0; i < allNums.length; i += step) {
            const num = allNums[i];
            const tickPosPercent = ((num - scaleMin) / rangeOfScale) * 100;
            
            if (tickPosPercent >= 0 && tickPosPercent <= 100) {
                const tick = document.createElement('div');
                tick.className = 'timeline-tick';
                tick.style.left = `${tickPosPercent}%`;
                timelineContainer.appendChild(tick);

                const label = document.createElement('div');
                label.className = 'timeline-tick-label';
                label.textContent = num;
                label.style.left = `${tickPosPercent}%`;
                timelineContainer.appendChild(label);
            }
        }
        
        function getPercent(val) {
            return ((val - scaleMin) / rangeOfScale) * 100;
        }

        // Update current range marker
        if (currentRange && currentRange[0] !== null && currentRange[1] !== null) {
            const curStartPercent = getPercent(currentRange[0]);
            const curEndPercent = getPercent(currentRange[1]);
            timelineCurrentRangeEl.style.left = `${Math.max(0, curStartPercent)}%`;
            timelineCurrentRangeEl.style.width = `${Math.min(100 - Math.max(0, curStartPercent), curEndPercent - curStartPercent)}%`;
            timelineCurrentRangeEl.style.opacity = '0.3';
        } else {
            timelineCurrentRangeEl.style.width = '0%';
            timelineCurrentRangeEl.style.opacity = '0';
        }

        // Update smallest range marker
        if (smallestRange && smallestRange[0] !== null && smallestRange[1] !== null && smallestRange[1] !== Infinity) {
            const bestStartPercent = getPercent(smallestRange[0]);
            const bestEndPercent = getPercent(smallestRange[1]);
            timelineSmallestRangeEl.style.left = `${Math.max(0, bestStartPercent)}%`;
            timelineSmallestRangeEl.style.width = `${Math.min(100 - Math.max(0, bestStartPercent), bestEndPercent - bestStartPercent)}%`;
             timelineSmallestRangeEl.style.opacity = '0.4'; // Slightly more opaque
        } else {
            timelineSmallestRangeEl.style.width = '0%';
            timelineSmallestRangeEl.style.opacity = '0';
        }
        
        // Update min/max pointers (current range considered)
        if (minPtrVal !== null) {
            timelineMinPointerEl.style.left = `${getPercent(minPtrVal)}%`;
            timelineMinPointerEl.style.opacity = '1';
        } else {
            timelineMinPointerEl.style.opacity = '0';
        }
        if (maxPtrVal !== null) {
            timelineMaxPointerEl.style.left = `${getPercent(maxPtrVal)}%`; // position at start of the 'pixel'
            timelineMaxPointerEl.style.opacity = '1';
        } else {
            timelineMaxPointerEl.style.opacity = '0';
        }
    }

    function updateUI(state) {
        currentStepState = state;
        if (!state) return;

        kValueDisplay.textContent = kLists.length; 
        renderInputLists(kLists, state.highlight?.elementInList); 
        renderHeap(state.heapElements || [], state.action, state.actionItemKey);
        updateMetricsDisplays(
            state.currentMaxInHeap, 
            state.currentRangeConsidered,
            state.smallestRangeFound,
            state.smallestRangeLength,
            state.smallestRangeWasUpdated
        );
        renderTimeline(
            allUniqueSortedNumbers, timelineScaleMin, timelineScaleMax,
            state.currentRangeConsidered, 
            state.smallestRangeFound,
            state.currentRangeConsidered ? state.currentRangeConsidered[0] : null, // min pointer
            state.currentRangeConsidered ? state.currentRangeConsidered[1] : null  // max pointer
        );
        
        statusMessage.textContent = state.statusText || "";
        highlightCodeLine(state.codeLineId);

        nextStepBtn.disabled = state.isDone || isAutoPlaying;
        autoPlayBtn.disabled = state.isDone;
        autoPlayBtn.textContent = isAutoPlaying ? "Pause" : "Auto Play";
    }

    // --- Generator for Algorithm Steps ---
    // (Generator logic is the same as the previous "Smallest Range" one,
    //  just ensure it yields `currentRangeConsidered` with [min_popped, current_max_in_heap])
    function* smallestRangeGenerator(lists) {
        const k = lists.length;
        if (k === 0 || lists.some(l => l.length === 0)) {
            yield { statusText: "Input lists cannot be empty or contain empty lists.", isDone: true, heapElements: [], smallestRangeFound: null, smallestRangeLength: Infinity, currentMaxInHeap: -Infinity, currentRangeConsidered: null };
            return;
        }

        minHeap.clear();
        let currentMaxInHeap = -Infinity;
        let rangeStart = 0, rangeEnd = Infinity; // Initial best range
        let smallestRangeLength = Infinity;

        // Setup for timeline scale
        let allNumbersFlat = lists.flat();
        allUniqueSortedNumbers = [...new Set(allNumbersFlat)].sort((a,b) => a-b);
        if (allUniqueSortedNumbers.length > 0) {
            timelineScaleMin = allUniqueSortedNumbers[0];
            timelineScaleMax = allUniqueSortedNumbers[allUniqueSortedNumbers.length - 1];
            if (timelineScaleMin === timelineScaleMax) { // Handle case with all same numbers
                timelineScaleMin -=1; timelineScaleMax +=1;
            }
        } else { // No numbers
             timelineScaleMin = 0; timelineScaleMax = 1;
        }


        yield { 
            heapElements: [], currentMaxInHeap, smallestRangeFound: null, smallestRangeLength, currentRangeConsidered: null,
            statusText: "1. Initializing variables.", codeLineId: 'code-0', isDone: false, highlight: {}
        };

        for (let i = 0; i < k; i++) {
            yield {
                heapElements: minHeap.getElements(), currentMaxInHeap, smallestRangeFound: null, smallestRangeLength, currentRangeConsidered: null,
                statusText: `Considering List ${i} for initial heap population.`, codeLineId: 'code-2',
                isDone: false, highlight: { elementInList: { listIdx: i, elementIdx: 0, type: 'next_candidate' } }
            };
            const firstVal = lists[i][0];
            const heapItem = { val: firstVal, listIdx: i, elementIdxInList: 0 };
            minHeap.push(heapItem);
            currentMaxInHeap = Math.max(currentMaxInHeap, firstVal);
            yield {
                heapElements: minHeap.getElements(), currentMaxInHeap, smallestRangeFound: null, smallestRangeLength, currentRangeConsidered: null,
                statusText: `Added ${firstVal} (L${i},E0) to heap. Current max in scope: ${currentMaxInHeap}.`,
                codeLineId: 'code-5', isDone: false,
                highlight: { elementInList: { listIdx: i, elementIdx: 0, type: 'current_max' } }, 
                action: 'ADD', actionItemKey: heapItem.key
            };
        }
        
        // Initial range update after heap is populated
        let initialHeapMin = minHeap.peek() ? minHeap.peek().val : null;
        let initialCurrentRange = initialHeapMin !== null ? [initialHeapMin, currentMaxInHeap] : null;

        if(initialCurrentRange && (currentMaxInHeap - initialHeapMin < rangeEnd - rangeStart)) {
            rangeStart = initialHeapMin;
            rangeEnd = currentMaxInHeap;
            smallestRangeLength = rangeEnd - rangeStart;
        }

        yield { 
            heapElements: minHeap.getElements(), currentMaxInHeap, 
            smallestRangeFound: [rangeStart, rangeEnd], smallestRangeLength, 
            currentRangeConsidered: initialCurrentRange,
            statusText: `Heap initialized. Max in scope: ${currentMaxInHeap}. Initial best range: [${rangeStart}, ${rangeEnd}].`,
            codeLineId: 'code-6', isDone: false, highlight: {}
        };


        while (true) { 
             if (minHeap.size() < k) { break; }
            yield { 
                heapElements: minHeap.getElements(), currentMaxInHeap, smallestRangeFound: [rangeStart, rangeEnd], smallestRangeLength, currentRangeConsidered: null, // Clear current range before new pop
                statusText: "Extracting min from heap to define current range's start.",
                codeLineId: 'code-7', isDone: false, highlight: {}
            };

            const itemToPop = minHeap.peek();
            yield { 
                heapElements: minHeap.getElements(), currentMaxInHeap, smallestRangeFound: [rangeStart, rangeEnd], smallestRangeLength, currentRangeConsidered: null,
                statusText: `Smallest in heap: ${itemToPop.val} (L${itemToPop.listIdx}). Preparing to pop.`,
                codeLineId: 'code-8', isDone: false,
                highlight: {}, action: 'PRE_POP', actionItemKey: itemToPop.key
            };

            const popped = minHeap.pop();
            const minValPopped = popped.val;
            
            // Current range defined by popped min and existing currentMaxInHeap
            let currentRangeConsideredNow = [minValPopped, currentMaxInHeap];
            yield { 
                heapElements: minHeap.getElements(), currentMaxInHeap, smallestRangeFound: [rangeStart, rangeEnd], smallestRangeLength,
                currentRangeConsidered: currentRangeConsideredNow,
                statusText: `Popped ${minValPopped} (L${popped.listIdx}). Current range considered: [${minValPopped}, ${currentMaxInHeap}].`,
                codeLineId: 'code-9', isDone: false,
                highlight: { elementInList: { listIdx: popped.listIdx, elementIdx: popped.elementIdxInList, type: 'popped_min' } }
            };

            let rangeUpdatedThisStep = false;
            if (currentMaxInHeap - minValPopped < rangeEnd - rangeStart) {
                rangeStart = minValPopped;
                rangeEnd = currentMaxInHeap;
                rangeUpdatedThisStep = true;
            } else if (currentMaxInHeap - minValPopped === rangeEnd - rangeStart && minValPopped < rangeStart) {
                rangeStart = minValPopped;
                rangeEnd = currentMaxInHeap;
                rangeUpdatedThisStep = true;
            }
            smallestRangeLength = rangeEnd - rangeStart;

            yield {
                heapElements: minHeap.getElements(), currentMaxInHeap, 
                smallestRangeFound: [rangeStart, rangeEnd], smallestRangeLength,
                currentRangeConsidered: currentRangeConsideredNow,
                smallestRangeWasUpdated: rangeUpdatedThisStep,
                statusText: rangeUpdatedThisStep ? `New smallest range: [${rangeStart}, ${rangeEnd}].` : `Current range [${minValPopped},${currentMaxInHeap}] not smaller.`,
                codeLineId: 'code-10', isDone: false,
                highlight: {}
            };


            const nextElementIdx = popped.elementIdxInList + 1;
            yield { 
                 heapElements: minHeap.getElements(), currentMaxInHeap, smallestRangeFound: [rangeStart, rangeEnd], smallestRangeLength,
                 currentRangeConsidered: currentRangeConsideredNow,
                 statusText: `Advancing pointer in List ${popped.listIdx}.`,
                 codeLineId: 'code-12', isDone: false, highlight: {}
            };

            if (nextElementIdx < lists[popped.listIdx].length) {
                const nextVal = lists[popped.listIdx][nextElementIdx];
                 yield { 
                    heapElements: minHeap.getElements(), currentMaxInHeap, smallestRangeFound: [rangeStart, rangeEnd], smallestRangeLength,
                    currentRangeConsidered: currentRangeConsideredNow,
                    statusText: `List ${popped.listIdx} has next element: ${nextVal}. Adding to heap.`,
                    codeLineId: 'code-14', isDone: false,
                    highlight: { elementInList: { listIdx: popped.listIdx, elementIdx: nextElementIdx, type: 'next_candidate' } }
                };

                const newItemForHeap = { val: nextVal, listIdx: popped.listIdx, elementIdxInList: nextElementIdx };
                minHeap.push(newItemForHeap);
                currentMaxInHeap = Math.max(currentMaxInHeap, nextVal); // Update max with the new element added
                yield {
                    heapElements: minHeap.getElements(), currentMaxInHeap, smallestRangeFound: [rangeStart, rangeEnd], smallestRangeLength,
                    currentRangeConsidered: null, // Old current range no longer primary focus
                    statusText: `Added ${nextVal} (L${popped.listIdx},E${nextElementIdx}). New current max in scope: ${currentMaxInHeap}.`,
                    codeLineId: 'code-16', isDone: false,
                    highlight: {}, action: 'ADD', actionItemKey: newItemForHeap.key
                };
            } else { 
                yield {
                    heapElements: minHeap.getElements(), currentMaxInHeap, smallestRangeFound: [rangeStart, rangeEnd], smallestRangeLength,
                    currentRangeConsidered: currentRangeConsideredNow, // Keep showing last valid range
                    statusText: `List ${popped.listIdx} exhausted. Cannot form range with all lists.`,
                    codeLineId: 'code-17', isDone: true, 
                    highlight: {}
                };
                break; 
            }
             if (minHeap.size() === k) { 
                 yield { 
                    heapElements: minHeap.getElements(), currentMaxInHeap, smallestRangeFound: [rangeStart, rangeEnd], smallestRangeLength, currentRangeConsidered:null,
                    statusText: "Preparing for next range check...",
                    codeLineId: 'code-7', isDone: false, highlight: {}
                };
            } else { break; }
        }

        yield {
            heapElements: minHeap.getElements(), currentMaxInHeap, 
            smallestRangeFound: [rangeStart, rangeEnd], smallestRangeLength,
            currentRangeConsidered: null, 
            statusText: `Algorithm finished. Smallest range: [${rangeStart}, ${rangeEnd}].`,
            codeLineId: 'code-19', isDone: true, highlight: {}
        };
    }


    // --- Control Functions --- (Mostly same, ensure timeline related vars are reset/initialized)
    function parseInputs() { /* ... (same) ... */
        const inputText = listsInputEl.value.trim();
        if (!inputText) { kLists = []; return; }
        kLists = inputText.split('\n')
            .map(line => line.trim().split(',')
                .map(s => parseInt(s.trim()))
                .filter(n => !isNaN(n))
            )
            .filter(list => list.length > 0); 
        kLists.forEach(list => list.sort((a,b) => a-b)); 
    }

    function initializeAlgorithm() { /* ... (same + init timeline vars) ... */
        stopAutoPlay();
        parseInputs(); 
        if (kLists.length === 0 || kLists.some(l => l.length === 0)) {
            statusMessage.textContent = "Invalid input: All lists must be non-empty.";
            kValueDisplay.textContent = '0'; renderInputLists([]); renderHeap([]); 
            updateMetricsDisplays(-Infinity, null, null, Infinity);
            renderTimeline([],0,1); // Clear timeline
            highlightCodeLine(null);
            nextStepBtn.disabled = true; autoPlayBtn.disabled = true;
            return;
        }
        // Prepare timeline scale data
        let allNumbersFlat = kLists.flat();
        allUniqueSortedNumbers = [...new Set(allNumbersFlat)].sort((a,b) => a-b);
        if (allUniqueSortedNumbers.length > 0) {
            timelineScaleMin = allUniqueSortedNumbers[0];
            timelineScaleMax = allUniqueSortedNumbers[allUniqueSortedNumbers.length - 1];
            if (timelineScaleMin === timelineScaleMax && allUniqueSortedNumbers.length === 1) { // Handle single unique number case
                 timelineScaleMin -= 1; timelineScaleMax += 1;
            } else if (timelineScaleMin === timelineScaleMax) { // All lists empty or same single value
                 timelineScaleMin = 0; timelineScaleMax = 1; // Default if no range
            }
        } else {
             timelineScaleMin = 0; timelineScaleMax = 1; // Default if no numbers
        }


        algorithmGen = smallestRangeGenerator(kLists); 
        handleNextStep();
        listsInputEl.disabled = true;
        resetBtn.disabled = false;
    }

    function handleNextStep() { /* Standard */
        if (!algorithmGen) { initializeAlgorithm(); return; }
        const step = algorithmGen.next();
        if (step.value) updateUI(step.value);
        if (step.done) {
            algorithmGen = null; listsInputEl.disabled = false;
        }
    }
    function startAutoPlay() { /* Standard */
        if (!algorithmGen || currentStepState?.isDone) {
            initializeAlgorithm();
            if (!algorithmGen || (currentStepState && currentStepState.isDone)) return;
        }
        isAutoPlaying = true;
        autoPlayBtn.textContent = "Pause"; nextStepBtn.disabled = true;
        function autoStep() {
            if (!isAutoPlaying || !algorithmGen) return;
            const step = algorithmGen.next();
            if (step.value) updateUI(step.value);
            if (step.done || !step.value || step.value.isDone) {
                stopAutoPlay(); algorithmGen = null; listsInputEl.disabled = false;
                if(step.value && step.value.isDone) updateUI(step.value);
            } else {
                autoPlayTimeoutId = setTimeout(autoStep, animationSpeed);
            }
        }
        autoStep();
    }
    function stopAutoPlay() { /* Standard */
        isAutoPlaying = false;
        if (autoPlayTimeoutId) clearTimeout(autoPlayTimeoutId);
        autoPlayBtn.textContent = "Auto Play";
        if (currentStepState) nextStepBtn.disabled = currentStepState.isDone;
    }
    function reset() { /* Standard + timeline reset */
        stopAutoPlay(); algorithmGen = null; currentStepState = null; minHeap.clear();
        listsInputEl.disabled = false;
        resetBtn.disabled = true; nextStepBtn.disabled = false; autoPlayBtn.disabled = false;
        autoPlayBtn.textContent = "Auto Play";

        parseInputs(); 
        kValueDisplay.textContent = kLists.length;
        renderInputLists(kLists);
        renderHeap([]); 
        updateMetricsDisplays(-Infinity, null, null, Infinity);
        
        // Reset timeline data and render empty
        allUniqueSortedNumbers = []; timelineScaleMin=0; timelineScaleMax=1;
        renderTimeline([],0,1);

        statusMessage.textContent = "Enter lists (one per line, comma-separated), then click Reset.";
        highlightCodeLine(null);
    }

    resetBtn.addEventListener('click', reset);
    nextStepBtn.addEventListener('click', handleNextStep);
    autoPlayBtn.addEventListener('click', () => { if (isAutoPlaying) stopAutoPlay(); else startAutoPlay(); });
    speedSlider.addEventListener('input', e => animationSpeed = 2100 - parseInt(e.target.value));
    window.addEventListener('load', () => { animationSpeed = 2100 - parseInt(speedSlider.value); reset(); });
    window.addEventListener('resize', () => { 
        if(currentStepState) {
            updateUI(currentStepState); // This will re-render timeline based on current state
        } else {
            reset(); // Or full reset if no active state
        }
    });
</script>
</body>
</html>