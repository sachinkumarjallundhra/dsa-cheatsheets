<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimize Malware Spread Cheat Sheet</title>
    <link rel="stylesheet" href="../style.css" />
</head>
<body>
    <div class="container">
        <p class="no-print"><a href="../index.html">‚Üê Back to Index</a></p>
        <h1>ü¶† Minimize Malware Spread ‚Äì Java Cheat Sheet</h1>

        <h2>üìå What Is It?</h2>
        <p>
            The <b>Minimize Malware Spread</b> problem (LeetCode 924) asks you to remove one node from a network (represented as a graph) to minimize the spread of malware. The graph is given as an adjacency matrix, and some nodes are initially infected. Return the node whose removal minimizes the final number of infected nodes (smallest index in case of a tie).
        </p>

        <h2>üéØ Solution Pattern (Union Find / DSU)</h2>
        <pre><code>// Java Solution (Union Find)
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        UnionFind uf = new UnionFind(n);
        // Union all connected nodes
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (graph[i][j] == 1) uf.union(i, j);
            }
        }
        // Count size of each component
        int[] size = new int[n];
        for (int i = 0; i < n; i++) {
            size[uf.find(i)]++;
        }
        // Count malware in each component
        int[] malware = new int[n];
        for (int node : initial) {
            malware[uf.find(node)]++;
        }
        // Find the best node to remove
        int res = -1, maxSaved = -1;
        Arrays.sort(initial);
        for (int node : initial) {
            int root = uf.find(node);
            if (malware[root] == 1) { // Only one malware in this component
                if (size[root] > maxSaved) {
                    maxSaved = size[root];
                    res = node;
                }
            }
        }
        return res == -1 ? initial[0] : res;
    }
}

class UnionFind {
    int[] parent;
    public UnionFind(int n) {
        parent = new int[n];
        for (int i = 0; i < n; i++) parent[i] = i;
    }
    public int find(int x) {
        if (parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }
    public void union(int x, int y) {
        int px = find(x), py = find(y);
        if (px != py) parent[px] = py;
    }
}
</code></pre>
<button onclick="window.location.href='../animations/minimize_malware_spread_animation.html'" class="animation-btn">
    ‚ñ∂Ô∏è View Animation
</button>

        <h2>‚úÖ Use Cases</h2>
        <ul>
            <li>Network security and malware containment</li>
            <li>Connected components in graphs</li>
            <li>Union Find applications</li>
        </ul>

        <h2>üìù Algorithm Steps</h2>
        <ol>
            <li>Union all connected nodes to form components</li>
            <li>Count the size of each component</li>
            <li>Count the number of malware nodes in each component</li>
            <li>For each initially infected node, check if removing it saves the most nodes</li>
            <li>Return the node with the maximum saved, or the smallest index in case of a tie</li>
        </ol>

        <h2>‚è±Ô∏è Time Complexity</h2>
        <ul>
            <li><b>Time:</b> <code>O(N^2)</code> where N is the number of nodes</li>
            <li><b>Space:</b> <code>O(N)</code> for Union Find and counting arrays</li>
        </ul>

        <h2>‚ö†Ô∏è Edge Cases to Consider</h2>
        <ul>
            <li>All nodes are initially infected</li>
            <li>Multiple nodes save the same number of nodes (return the smallest index)</li>
            <li>Disconnected graph</li>
        </ul>

        <h2>üß™ Example</h2>
        <pre><code>Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0

Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
Output: 