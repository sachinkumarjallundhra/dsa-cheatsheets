<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Search II Cheat Sheet</title>
    <link rel="stylesheet" href="../style.css" />
</head>
<body>
    <div class="container">
        <p class="no-print"><a href="../index.html">‚Üê Back to Index</a></p>
        <h1>üîé Word Search II ‚Äì Java Cheat Sheet</h1>

        <h2>üìå What Is It?</h2>
        <p>
            The <b>Word Search II</b> problem (LeetCode 212) asks you to find all words from a given list that can be formed by sequentially adjacent letters on a 2D board. Each cell can be used only once per word.
        </p>

        <h2>üéØ Solution Pattern (Trie + DFS Backtracking)</h2>
        <pre><code>// Java Solution
class TrieNode {
    TrieNode[] children = new TrieNode[26];
    String word = null;
}

class Solution {
    public List&lt;String&gt; findWords(char[][] board, String[] words) {
        List&lt;String&gt; res = new ArrayList&lt;&gt;();
        TrieNode root = buildTrie(words);
        int m = board.length, n = board[0].length;
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                dfs(board, i, j, root, res);
            }
        }
        return res;
    }

    private void dfs(char[][] board, int i, int j, TrieNode node, List&lt;String&gt; res) {
        char c = board[i][j];
        if (c == '#' || node.children[c - 'a'] == null) return;
        node = node.children[c - 'a'];
        if (node.word != null) {
            res.add(node.word);
            node.word = null; // avoid duplicates
        }
        board[i][j] = '#';
        int[] dx = {0, 0, 1, -1}, dy = {1, -1, 0, 0};
        for (int d = 0; d &lt; 4; d++) {
            int x = i + dx[d], y = j + dy[d];
            if (x &gt;= 0 && x &lt; board.length && y &gt;= 0 && y &lt; board[0].length) {
                dfs(board, x, y, node, res);
            }
        }
        board[i][j] = c;
    }

    private TrieNode buildTrie(String[] words) {
        TrieNode root = new TrieNode();
        for (String word : words) {
            TrieNode node = root;
            for (char c : word.toCharArray()) {
                int idx = c - 'a';
                if (node.children[idx] == null) node.children[idx] = new TrieNode();
                node = node.children[idx];
            }
            node.word = word;
        }
        return root;
    }
}
</code></pre>
<button onclick="window.location.href='../animations/word_search_ii_animation.html'" class="animation-btn">
    ‚ñ∂Ô∏è View Animation
</button>
<p>
    <a href="https://www.youtube.com/watch?v=asbcE9mZz_U&ab_channel=NeetCode" target="_blank">
        ‚ñ∂Ô∏è Watch Video Explanation on YouTube (NeetCode)
    </a>
</p>

        <h2>‚úÖ Use Cases</h2>
        <ul>
            <li>Finding multiple words in a grid</li>
            <li>Efficient prefix search in 2D arrays</li>
            <li>Backtracking with pruning</li>
        </ul>

        <h2>üìù Algorithm Steps</h2>
        <ol>
            <li>Build a Trie from the word list</li>
            <li>For each cell in the board, start DFS if the character matches a Trie child</li>
            <li>Mark visited cells to avoid reuse</li>
            <li>Collect found words and avoid duplicates</li>
        </ol>

        <h2>‚ö†Ô∏è Edge Cases to Consider</h2>
        <ul>
            <li>Empty board or word list</li>
            <li>Words with shared prefixes</li>
            <li>Words longer than board dimensions</li>
        </ul>

        <h2>üß™ Example</h2>
        <pre><code>Input: board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
Output: ["eat","oath"]
Explanation: Only "eat" and "oath" can be formed from the board.
</code></pre>
    </div>
