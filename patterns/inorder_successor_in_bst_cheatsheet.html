<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inorder Successor in BST Cheat Sheet</title>
    <link rel="stylesheet" href="../style.css" />
</head>
<body>
    <div class="container">
        <p class="no-print"><a href="../index.html">‚Üê Back to Index</a></p>
        <h1>‚û°Ô∏è Inorder Successor in BST ‚Äì Java Cheat Sheet</h1>

        <h2>üìå What Is It?</h2>
        <p>
            The <b>Inorder Successor in BST</b> problem (LeetCode 285) asks you to find the next node in the inorder traversal of a Binary Search Tree (BST) for a given node.
        </p>

        <h2>üéØ Solution Pattern (Iterative & Recursive)</h2>
        <h3>Iterative Solution</h3>
        <pre><code>public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
    TreeNode successor = null;
    while (root != null) {
        if (p.val < root.val) {
            successor = root;
            root = root.left;
        } else {
            root = root.right;
        }
    }
    return successor;
}
</code></pre>
<button onclick="window.location.href='../animations/inorder_successor_in_bst_bfs_animation.html'" class="animation-btn">
    ‚ñ∂Ô∏è View Animation
</button>

        <h3>Recursive Solution</h3>
        <pre><code>public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
    if (root == null) return null;
    if (p.val < root.val) {
        TreeNode left = inorderSuccessor(root.left, p);
        return left != null ? left : root;
    } else {
        return inorderSuccessor(root.right, p);
    }
}
</code></pre>
<button onclick="window.location.href='../animations/inorder_successor_in_bst_dfs_animation.html'" class="animation-btn">
    ‚ñ∂Ô∏è View Animation
</button>

        <h2>‚úÖ Use Cases</h2>
        <ul>
            <li>Finding next node in BST traversal</li>
            <li>Tree-based navigation and search</li>
            <li>Interview and coding test problems</li>
        </ul>

        <h2>üìù Algorithm Steps</h2>
        <ol>
            <li>Start from root and search for the node</li>
            <li>If node has right child, successor is leftmost node in right subtree</li>
            <li>If no right child, successor is the lowest ancestor for which node is in left subtree</li>
        </ol>

        <h2>‚ö†Ô∏è Edge Cases to Consider</h2>
        <ul>
            <li>Node is the largest (no successor)</li>
            <li>Node has right subtree</li>
            <li>Node is root or leaf</li>
        </ul>

        <h2>üß™ Example</h2>
        <pre><code>Input: root = [2,1,3], p = 1
Output: 2

Input: root = [5,3,6,2,4,null,null,1], p = 4
Output: 5
</code></pre>

        <h2>üí° Pro Tips</h2>
        <ul>
            <li>Use BST properties for efficient search</li>
            <li>Iterative solution is space efficient</li>
            <li>Recursive solution is concise</li>
        </ul>

        <h2>üîó Related Problems</h2>
        <ul class="problems-list">
            <li>
                <a href="validate_binary_search_tree_cheatsheet.html" class="problem-link">
                    <div class="problem-title">
                        Validate Binary Search Tree
                        <span class="badge badge-easy">Easy</span>
                    </div>
                </a>
            </li>
            <li>
                <a href="convert_sorted_array_to_binary_search_tree_cheatsheet.html" class="problem-link">
                    <div class="problem-title">
                        Convert Sorted Array to Binary Search Tree
                        <span class="badge badge-easy">Easy</span>
                    </div>
                </a>
            </li>
        </ul>
    </div>
</body>
</html>