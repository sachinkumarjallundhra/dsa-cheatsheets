<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Valid Tree Cheat Sheet</title>
    <link rel="stylesheet" href="../style.css" />
</head>
<body>
    <div class="container">
        <p class="no-print"><a href="../index.html">â† Back to Index</a></p>
        <h1>ğŸŒ³ Graph Valid Tree â€“ Java Cheat Sheet</h1>

        <h2>ğŸ“Œ What Is It?</h2>
        <p>
            The <b>Graph Valid Tree</b> problem (LeetCode 261) asks you to determine if an undirected graph is a valid tree. 
            A graph is a valid tree if it has no cycles and all nodes are connected.
        </p>

        <h2>ğŸ¯ Solution Pattern (Union Find)</h2>
        <pre><code>class Solution {
    private int[] parent;
    private int[] rank;
    
    public boolean validTree(int n, int[][] edges) {
        // Initialize Union-Find data structure
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i &lt; n; i++) {
            parent[i] = i;
            rank[i] = 1;
        }
        
        // Check if adding each edge creates a cycle
        for (int[] edge : edges) {
            int x = find(edge[0]);
            int y = find(edge[1]);
            
            if (x == y) return false; // Cycle detected
            union(x, y);
        }
        
        // Check if all nodes are connected
        int components = 0;
        for (int i = 0; i &lt; n; i++) {
            if (parent[i] == i) components++;
        }
        
        // Tree must have exactly n-1 edges and be fully connected
        return edges.length == n - 1 &amp;&amp; components == 1;
    }
    
    private int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // Path compression
        }
        return parent[x];
    }
    
    private void union(int x, int y) {
        if (rank[x] &lt; rank[y]) {
            parent[x] = y;
        } else if (rank[x] &gt; rank[y]) {
            parent[y] = x;
        } else {
            parent[y] = x;
            rank[x]++;
        }
    }
}</code></pre>
        <button onclick="window.location.href='../animations/graph_valid_tree_animation.html'">â–¶ï¸ View Animation</button>

        <h2>âœ… Use Cases</h2>
        <ul>
            <li>Network topology validation</li>
            <li>Circuit design verification</li>
            <li>Dependency graph validation</li>
            <li>Hierarchical structure verification</li>
        </ul>

        <h2>ğŸ“ Algorithm Steps</h2>
        <ol>
            <li>Initialize Union-Find data structure</li>
            <li>Process each edge and check for cycles</li>
            <li>If cycle found, return false</li>
            <li>Count number of connected components</li>
            <li>Verify edge count equals n-1</li>
            <li>Ensure single connected component</li>
        </ol>

        <h2>âš ï¸ Edge Cases to Consider</h2>
        <ul>
            <li>Empty graph (n = 0)</li>
            <li>Single node graph</li>
            <li>Disconnected components</li>
            <li>Multiple edges between same nodes</li>
            <li>Self loops</li>
            <li>Wrong number of edges</li>
        </ul>

        <h2>ğŸ§ª Example</h2>
        <pre><code>Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]
Output: true
Explanation: The given graph forms a tree with 5 nodes and 4 edges

Input: n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]
Output: false
Explanation: The given graph has a cycle: 1-2-3-1</code></pre>

        <h2>ğŸ’¡ Pro Tips</h2>
        <ul>
            <li>Use Union-Find with path compression and rank for optimal performance</li>
            <li>Remember both conditions: no cycles and fully connected</li>
            <li>Check edge count before processing for quick validation</li>
            <li>Consider using DFS/BFS as alternative approach</li>
            <li>Verify input constraints before processing</li>
        </ul>

        <h2>ğŸ”— Related Problems</h2>
        <ul class="problems-list">
            <li>
                <a href="redundant_connection_cheatsheet.html" class="problem-link">
                    <div class="problem-title">
                        684. Redundant Connection
                        <span class="badge badge-medium">Medium</span>
                    </div>
                </a>
            </li>
            <li>
                <a href="number_of_connected_components_cheatsheet.html" class="problem-link">
                    <div class="problem-title">
                        323. Number of Connected Components in an Undirected Graph
                        <span class="badge badge-medium">Medium</span>
                    </div>
                </a>
            </li>
        </ul>

        <h2>ğŸ¯ Alternative Solution 1 (DFS)</h2>
        <pre><code>class Solution {
    private List&lt;List&lt;Integer&gt;&gt; graph;
    private boolean[] visited;
    
    public boolean validTree(int n, int[][] edges) {
        // Early return if edge count is wrong
        if (edges.length != n - 1) return false;
        
        // Build adjacency list
        graph = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            graph.add(new ArrayList&lt;&gt;());
        }
        for (int[] edge : edges) {
            graph.get(edge[0]).add(edge[1]);
            graph.get(edge[1]).add(edge[0]);
        }
        
        // DFS to check connectivity
        visited = new boolean[n];
        if (!dfs(0, -1)) return false;
        
        // Check if all nodes were visited
        for (boolean v : visited) {
            if (!v) return false;
        }
        return true;
    }
    
    private boolean dfs(int node, int parent) {
        visited[node] = true;
        
        for (int neighbor : graph.get(node)) {
            if (neighbor == parent) continue;
            if (visited[neighbor]) return false;  // Cycle detected
            if (!dfs(neighbor, node)) return false;
        }
        return true;
    }
}</code></pre>

        <h2>ğŸ¯ Alternative Solution 2 (BFS)</h2>
        <pre><code>class Solution {
    public boolean validTree(int n, int[][] edges) {
        // Early return if edge count is wrong
        if (edges.length != n - 1) return false;
        
        // Build adjacency list
        List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            graph.add(new ArrayList&lt;&gt;());
        }
        for (int[] edge : edges) {
            graph.get(edge[0]).add(edge[1]);
            graph.get(edge[1]).add(edge[0]);
        }
        
        // BFS traversal
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        boolean[] visited = new boolean[n];
        queue.offer(0);
        visited[0] = true;
        
        while (!queue.isEmpty()) {
            int node = queue.poll();
            for (int neighbor : graph.get(node)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.offer(neighbor);
                }
            }
        }
        
        // Check if all nodes were visited
        for (boolean v : visited) {
            if (!v) return false;
        }
        return true;
    }
}</code></pre>

        <h2>ğŸ’¡ Solution Comparison</h2>
        <ul>
            <li><strong>Union Find:</strong> Best for dynamic graphs, O(Î±(N)) per operation</li>
            <li><strong>DFS:</strong> Simple implementation, good for detecting cycles, O(V + E)</li>
            <li><strong>BFS:</strong> Level by level traversal, good for connected components, O(V + E)</li>
        </ul>
    </div>
</body>
</html>