<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Closest Node to Path in Tree Cheat Sheet</title>
    <link rel="stylesheet" href="../style.css" />
</head>
<body>
<div class="container">
    <p class="no-print"><a href="../index.html">â† Back to Index</a></p>
    <h1>ğŸŒ² Closest Node to Path in Tree â€“ Java Cheat Sheet</h1>

    <h2>ğŸ“Œ What Is It?</h2>
    <p>
        <b>LeetCode 2277. Closest Node to Path in Tree (Hard)</b><br>
        You are given a positive integer <code>n</code> representing the number of nodes in a tree, numbered from 0 to n - 1. You are also given a 2D integer array <code>edges</code> of length n - 1, where <code>edges[i] = [node1i, node2i]</code> denotes a bidirectional edge. You are given a 2D integer array <code>query</code> of length m, where <code>query[i] = [starti, endi, nodei]</code> means for the ith query, find the node on the path from <code>starti</code> to <code>endi</code> that is closest to <code>nodei</code>.<br>
        Return an integer array <code>answer</code> of length m, where <code>answer[i]</code> is the answer to the ith query.
    </p>

    <h2>ğŸ¯ Solution Pattern (DFS Path + BFS Closest)</h2>
    <pre><code>// Java Solution
class Solution {
    public int[] closestNode(int n, int[][] edges, int[][] query) {
        List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; i++) graph.add(new ArrayList&lt;&gt;());
        for (int[] e : edges) {
            graph.get(e[0]).add(e[1]);
            graph.get(e[1]).add(e[0]);
        }
        int[] res = new int[query.length];
        for (int i = 0; i &lt; query.length; i++) {
            int start = query[i][0], end = query[i][1], node = query[i][2];
            List&lt;Integer&gt; path = new ArrayList&lt;&gt;();
            boolean[] visited = new boolean[n];
            dfsPath(graph, start, end, visited, path);
            Set&lt;Integer&gt; pathSet = new HashSet&lt;&gt;(path);
            res[i] = bfsToPath(graph, node, pathSet);
        }
        return res;
    }

    private boolean dfsPath(List&lt;List&lt;Integer&gt;&gt; graph, int cur, int end, boolean[] visited, List&lt;Integer&gt; path) {
        visited[cur] = true;
        path.add(cur);
        if (cur == end) return true;
        for (int nei : graph.get(cur)) {
            if (!visited[nei] && dfsPath(graph, nei, end, visited, path)) return true;
        }
        path.remove(path.size() - 1);
        return false;
    }

    private int bfsToPath(List&lt;List&lt;Integer&gt;&gt; graph, int start, Set&lt;Integer&gt; pathSet) {
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        boolean[] visited = new boolean[graph.size()];
        queue.offer(start);
        visited[start] = true;
        while (!queue.isEmpty()) {
            int node = queue.poll();
            if (pathSet.contains(node)) return node;
            for (int nei : graph.get(node)) {
                if (!visited[nei]) {
                    visited[nei] = true;
                    queue.offer(nei);
                }
            }
        }
        return -1; // should not happen in a connected tree
    }
}
</code></pre>
    <p>
    <b>How it works:</b> For each query, use DFS to find the path from <code>start</code> to <code>end</code> and mark all nodes on the path. Then use BFS from <code>node</code> to find the closest node on the path.
    </p>

    <h2>âœ… Use Cases</h2>
    <ul>
        <li>Tree path queries</li>
        <li>Network routing and proximity</li>
        <li>Interview and coding test problems</li>
    </ul>

    <h2>ğŸ“ Algorithm Steps</h2>
    <ol>
        <li>Build adjacency list for the tree</li>
        <li>For each query, use DFS to find and mark the path from <code>start</code> to <code>end</code></li>
        <li>For each query, use BFS from <code>node</code> to find the nearest node on the path</li>
    </ol>

    <h2>âš ï¸ Edge Cases to Consider</h2>
    <ul>
        <li>Query node is already on the path</li>
        <li>Tree with only two nodes</li>
        <li>Multiple queries</li>
    </ul>

    <h2>ğŸ§ª Example</h2>
    <pre><code>Input: n = 5, edges = [[0,1],[1,2],[1,3],[3,4]], query = [[0,4,2],[0,4,4],[0,4,0]]
Output: [1,4,0]
Explanation: Path from 0 to 4 is [0,1,3,4]. Closest node on path to 2 is 1, to 4 is 4, to 0 is 0.
</code></pre>

    <h2>ğŸ’¡ Pro Tips</h2>
    <ul>
        <li>DFS is efficient for path finding in trees</li>
        <li>BFS ensures shortest distance to path node</li>
        <li>Use a set for fast path node lookup</li>
    </ul>
</div>
</body>
</html>