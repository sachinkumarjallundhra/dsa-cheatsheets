<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Find the Town Judge Cheat Sheet</title>
    <link rel="stylesheet" href="../style.css" />
</head>
<body>
    <div class="container">
        <p class="no-print"><a href="../index.html">← Back to Index</a></p>
        <h1>👨‍⚖️ Find the Town Judge – Java Cheat Sheet</h1>

        <h2>📌 What Is It?</h2>
        <p>
            The <b>Find the Town Judge</b> problem (LeetCode 997) asks you to identify the town judge in a group of N people. The judge is trusted by everyone but trusts no one. You are given a list of trust relationships.
        </p>

        <h2>🎯 Solution Pattern (Degree Counting)</h2>
        <pre><code>class Solution {
    public int findJudge(int n, int[][] trust) {
        int[] inDegree = new int[n + 1];
        int[] outDegree = new int[n + 1];
        
        for (int[] t : trust) {
            outDegree[t[0]]++;
            inDegree[t[1]]++;
        }
        
        for (int i = 1; i <= n; i++) {
            if (inDegree[i] == n - 1 && outDegree[i] == 0) {
                return i;
            }
        }
        return -1;
    }
}</code></pre>
        <button onclick="window.location.href='../animations/find_the_town_judge_animation.html'">▶️ View Animation</button>

        <h2>✅ Use Cases</h2>
        <ul>
            <li>Leadership identification in networks</li>
            <li>Social network analysis</li>
            <li>Finding isolated nodes with maximum incoming edges</li>
            <li>Trust relationship modeling</li>
        </ul>

        <h2>📝 Algorithm Steps</h2>
        <ol>
            <li>Initialize in-degree and out-degree arrays for all people</li>
            <li>For each trust relationship, increment out-degree for truster and in-degree for trustee</li>
            <li>Scan all people to find one with in-degree n-1 and out-degree 0</li>
            <li>If found, return their label; otherwise, return -1</li>
        </ol>

        <h2>⚠️ Edge Cases to Consider</h2>
        <ul>
            <li>No trust relationships</li>
            <li>Multiple candidates with in-degree n-1</li>
            <li>Judge trusts someone (should not happen)</li>
            <li>Single person town (judge is person 1)</li>
            <li>Disconnected trust graph</li>
        </ul>

        <h2>🧪 Example</h2>
        <pre><code>Input: n = 3, trust = [[1,3],[2,3]]
Output: 3
Explanation: Person 3 is trusted by everyone else and trusts no one.

Input: n = 3, trust = [[1,3],[2,3],[3,1]]
Output: -1
Explanation: Person 3 trusts person 1, so cannot be the judge.</code></pre>

        <h2>💡 Pro Tips</h2>
        <ul>
            <li>Judge must have in-degree n-1 and out-degree 0</li>
            <li>Use arrays for efficient counting</li>
            <li>Handle single person town as a special case</li>
            <li>Test with empty trust list and cycles</li>
        </ul>

        <h2>🔗 Related Problems</h2>
        <ul class="problems-list">
            <li>
                <a href="find_center_of_star_graph_cheatsheet.html" class="problem-link">
                    <div class="problem-title">
                        1791. Find Center of Star Graph
                        <span class="badge badge-easy">Easy</span>
                    </div>
                </a>
            </li>
            <li>
                <a href="minimum_number_of_vertices_to_reach_all_nodes_cheatsheet.html" class="problem-link">
                    <div class="problem-title">
                        1557. Minimum Number of Vertices to Reach All Nodes
                        <span class="badge badge-medium">Medium</span>
                    </div>
                </a>
            </li>
        </ul>
    </div>
</body>
</html>